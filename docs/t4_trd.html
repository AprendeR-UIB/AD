<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ES" xml:lang="ES"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Análisis de datos - 4&nbsp; Técnicas de reducción de Dimensionalidad</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./t5_clustering.html" rel="next">
<link href="./t3_inferencia.html" rel="prev">
<link href="./Figuras/atlas.jpeg" rel="icon" type="image/jpeg">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./t4_trd.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Técnicas de reducción de Dimensionalidad</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Análisis de datos</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/AprendeR-UIB/AD" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Alternar modo lector">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Presentación</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t1_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción al Análisis de Datos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t2_em.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Análisis Multivariante</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t3_inferencia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Inferencia multivariante en poblaciones normales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t4_trd.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Técnicas de reducción de Dimensionalidad</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t5_clustering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Agrupamiento (Clustering)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t6_series_temporales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Series temporales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referencias</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#análisis-de-componentes-principales" id="toc-análisis-de-componentes-principales" class="nav-link active" data-scroll-target="#análisis-de-componentes-principales"><span class="header-section-number">4.1</span> Análisis de Componentes Principales</a>
  <ul class="collapse">
  <li><a href="#matriz-tabla-de-datos" id="toc-matriz-tabla-de-datos" class="nav-link" data-scroll-target="#matriz-tabla-de-datos"><span class="header-section-number">4.1.1</span> Matriz (tabla) de datos</a></li>
  <li><a href="#enfoque-geométrico" id="toc-enfoque-geométrico" class="nav-link" data-scroll-target="#enfoque-geométrico"><span class="header-section-number">4.1.2</span> Enfoque geométrico</a></li>
  </ul></li>
  <li><a href="#cálculo-de-las-componentes" id="toc-cálculo-de-las-componentes" class="nav-link" data-scroll-target="#cálculo-de-las-componentes"><span class="header-section-number">4.2</span> Cálculo de las componentes</a>
  <ul class="collapse">
  <li><a href="#cálculo-de-la-primera-componente" id="toc-cálculo-de-la-primera-componente" class="nav-link" data-scroll-target="#cálculo-de-la-primera-componente"><span class="header-section-number">4.2.1</span> Cálculo de la primera componente</a></li>
  <li><a href="#ejemplo" id="toc-ejemplo" class="nav-link" data-scroll-target="#ejemplo"><span class="header-section-number">4.2.2</span> <span style="color: blue;"><em>Ejemplo:</em></span></a></li>
  <li><a href="#cálculo-de-la-segunda-componente" id="toc-cálculo-de-la-segunda-componente" class="nav-link" data-scroll-target="#cálculo-de-la-segunda-componente"><span class="header-section-number">4.2.3</span> Cálculo de la segunda componente</a></li>
  </ul></li>
  <li><a href="#propiedades-del-acp" id="toc-propiedades-del-acp" class="nav-link" data-scroll-target="#propiedades-del-acp"><span class="header-section-number">4.3</span> Propiedades del ACP</a>
  <ul class="collapse">
  <li><a href="#acp-con-la-matriz-de-covarianzas" id="toc-acp-con-la-matriz-de-covarianzas" class="nav-link" data-scroll-target="#acp-con-la-matriz-de-covarianzas"><span class="header-section-number">4.3.1</span> ACP con la matriz de covarianzas</a></li>
  <li><a href="#acp-normado-o-con-matriz-de-correlaciones" id="toc-acp-normado-o-con-matriz-de-correlaciones" class="nav-link" data-scroll-target="#acp-normado-o-con-matriz-de-correlaciones"><span class="header-section-number">4.3.2</span> ACP normado o con matriz de correlaciones</a></li>
  </ul></li>
  <li><a href="#análisis-de-componentes-principales-en-r" id="toc-análisis-de-componentes-principales-en-r" class="nav-link" data-scroll-target="#análisis-de-componentes-principales-en-r"><span class="header-section-number">4.4</span> Análisis de Componentes Principales en R</a>
  <ul class="collapse">
  <li><a href="#ejercicio" id="toc-ejercicio" class="nav-link" data-scroll-target="#ejercicio"><span class="header-section-number">4.4.1</span> Ejercicio:</a></li>
  </ul></li>
  <li><a href="#escalamiento-multidimensional-mds" id="toc-escalamiento-multidimensional-mds" class="nav-link" data-scroll-target="#escalamiento-multidimensional-mds"><span class="header-section-number">4.5</span> Escalamiento multidimensional (MDS)</a>
  <ul class="collapse">
  <li><a href="#reconstrucción-de-las-variables-a-partir-de-las-distancias-entre-puntos" id="toc-reconstrucción-de-las-variables-a-partir-de-las-distancias-entre-puntos" class="nav-link" data-scroll-target="#reconstrucción-de-las-variables-a-partir-de-las-distancias-entre-puntos"><span class="header-section-number">4.5.1</span> Reconstrucción de las variables a partir de las distancias entre puntos</a></li>
  <li><a href="#coordenadas-principales-a-partir-de-distancias" id="toc-coordenadas-principales-a-partir-de-distancias" class="nav-link" data-scroll-target="#coordenadas-principales-a-partir-de-distancias"><span class="header-section-number">4.5.2</span> Coordenadas principales a partir de distancias</a></li>
  </ul></li>
  <li><a href="#selección-del-número-de-dimensiones" id="toc-selección-del-número-de-dimensiones" class="nav-link" data-scroll-target="#selección-del-número-de-dimensiones"><span class="header-section-number">4.6</span> Selección del número de dimensiones</a>
  <ul class="collapse">
  <li><a href="#ejemplo-a-mano" id="toc-ejemplo-a-mano" class="nav-link" data-scroll-target="#ejemplo-a-mano"><span class="header-section-number">4.6.1</span> Ejemplo a mano</a></li>
  </ul></li>
  <li><a href="#mds-no-métrico" id="toc-mds-no-métrico" class="nav-link" data-scroll-target="#mds-no-métrico"><span class="header-section-number">4.7</span> MDS no métrico</a></li>
  <li><a href="#medidas-de-bondad-de-ajuste-de-la-solución-obtenida" id="toc-medidas-de-bondad-de-ajuste-de-la-solución-obtenida" class="nav-link" data-scroll-target="#medidas-de-bondad-de-ajuste-de-la-solución-obtenida"><span class="header-section-number">4.8</span> Medidas de bondad de ajuste de la solución obtenida</a></li>
  <li><a href="#escalamiento-multidimensional-en-r" id="toc-escalamiento-multidimensional-en-r" class="nav-link" data-scroll-target="#escalamiento-multidimensional-en-r"><span class="header-section-number">4.9</span> Escalamiento multidimensional en R</a></li>
  <li><a href="#práctica" id="toc-práctica" class="nav-link" data-scroll-target="#práctica"><span class="header-section-number">4.10</span> <span style="color: red;"><em>Práctica</em></span></a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/AprendeR-UIB/AD/edit/main/t4_trd.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li><li><a href="https://github.com/AprendeR-UIB/AD/issues/new" class="toc-action"><i class="bi empty"></i>Informar de un problema</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Técnicas de reducción de Dimensionalidad</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>La <strong>reducción de la dimensionalidad</strong> consiste en describir con cierta precisión los valores de las <span class="math inline">\(p\)</span> variables por un pequeño subconjunto <span class="math inline">\(r&lt;p\)</span> de ellas con una pérdida mínima de información. Por lo tanto, proyectaremos la muestra original en el nuevo subespacio pero conservando algunas características <span class="citation" data-cites="bakker">(véase <a href="referencias.html#ref-bakker" role="doc-biblioref">Bakker 2024</a>)</span>.</p>
<p>Algunos ámbitos importantes en los que es frecuente la utilización de la Reducción de la dimensionalidad podrían ser:</p>
<ul>
<li><p><strong>Reconocimiento facial</strong>: Al partir de una proyección facial de tamaño <span class="math inline">\(M \times N\)</span> píxeles puede resultar complicado el estudio completo de dicha imagen, puesto que da lugar a un vector con dimensión excesivamente alta. De modo que debemos reducir la dimensionalidad pero de forma que nos permita generar un sistema de clasificación facial de un individuo entre el resto de la población.</p></li>
<li><p><strong>Modelización de secuencias genómicas</strong>: Considera una proteína, formada por una secuencia de aminoácidos donde es posible encontrar hasta 20 tipos diferentes, su longitud puede llegar a ser de decenas hasta cientos de decenas de aminoácidos. De modo que, las proteínas con igual estructura pueden ser agrupadas en familias y el conjunto de familias proteicas distintas tendrá una dimensión inferior al conjunto de todas las proteínas. Pudiendo así encontrar de forma menos compleja propiedades particulares o incluso identificar nuevos miembros de una familia.</p></li>
</ul>
<section id="análisis-de-componentes-principales" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="análisis-de-componentes-principales"><span class="header-section-number">4.1</span> Análisis de Componentes Principales</h2>
<p>El análisis de componentes principales, PCA por sus siglas en inglés (<strong>P</strong>rincipal <strong>C</strong>omponent <strong>A</strong>nalysis), es uno de los métodos más populares del análisis multivariado.</p>
<p>El PCA se utiliza cuando deseamos obtener una representación en menor dimensión para un conjunto de variables cuantitativas correlacionadas y queremos expresar la información importante como un conjunto de pocas variables nuevas llamadas <strong>componentes principales</strong>. Estas componentes se corresponden con una combinación lineal de las variables originales.</p>
<p>Dado que la información de un conjunto de datos se corresponde a la variación total que contiene, el objetivo del PCA es identificar direcciones (o componentes principales) a lo largo de las cuales la variación en los datos es máxima.</p>
<section id="matriz-tabla-de-datos" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="matriz-tabla-de-datos"><span class="header-section-number">4.1.1</span> Matriz (tabla) de datos</h3>
<p>Supongamos que disponemos de una tabla de datos con los valores de <span class="math inline">\(p\)</span>-variables en <span class="math inline">\(n\)</span> elementos de una población arreglados en una matriz <span class="math inline">\(\mathbf{X}\)</span> de la siguiente forma:</p>
<table class="table">
<colgroup>
<col style="width: 12%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 17%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">ID</th>
<th style="text-align: center;"><span class="math inline">\(\bf{x}_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\bf{x}_2\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\ldots\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\bf{x}_p\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\bf{v}_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\bf{v}_2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{11}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{12}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\ldots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{1p}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(v_{11}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(v_{12}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{21}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{22}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\ldots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{2p}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(v_{21}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(v_{22}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{31}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{32}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\ldots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{3p}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(v_{31}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(v_{32}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\ddots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(n\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{n1}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{n2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\ldots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x_{np}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(v_{n1}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(v_{n2}\)</span></td>
</tr>
</tbody>
</table>
<ul>
<li><p>Donde las variables <span class="math inline">\(x_1,\ldots, x_n\)</span> describen a los <span class="math inline">\(n\)</span> individuos observados.</p></li>
<li><p>Las variables <span class="math inline">\(v_1\)</span>, <span class="math inline">\(v_2\)</span> son de perfil (o explicativas) y ayudan a interpretar la variabilidad de los datos.</p></li>
</ul>
<p>El objetivo del análisis es la <strong>reducción de la dimensionalidad</strong>. Buscamos un <strong>espacio de variables más reducido y fácil de interpretar</strong>.</p>
<p>El problema es que si reducimos el número de variables es posible que “perdamos parte toda la variabilidad de los datos originales”.</p>
<p>Así la idea básica es consentir una pérdida de información para lograr una ganancia en la significación.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Figuras/visualizacion_acp.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</section>
<section id="enfoque-geométrico" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="enfoque-geométrico"><span class="header-section-number">4.1.2</span> Enfoque geométrico</h3>
<p>Supongamos que <span class="math inline">\(p=2\)</span> y que la nube de puntos de nuestra matriz de datos es la de la siguiente figura:</p>
<div class="cell" data-layout-align="center" data-fig="true">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>La siguiente figura muestra las dos <strong>componentes principales</strong>, es decir, las direcciones de las proyecciones que tienen máxima variabilidad.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Figuras/cp1.png" class="lightbox" data-gallery="cp"><img src="Figuras/cp1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></a></p>
</figure>
</div>
<p>Si proyectamos en la dirección de la <strong>primera componente</strong> obtendremos las proyecciones siguientes (en color azul):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Figuras/cp2.png" class="lightbox" data-gallery="cp"><img src="Figuras/cp2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></a></p>
</figure>
</div>
<p>Lo que significa que la varianza de los puntos azules es máxima; en el sentido de que cualquier otra dirección o recta, las proyecciones sobre ésta tendrán a lo más igual varianza.</p>
<p>Los puntos azules representan las coordenadas que tienen los puntos de nuestra tabla de datos (centrada) tomando como eje de abcisas la <strong>primera componente</strong> <span class="math inline">\(CP_1\)</span>.</p>
<p>Si proyectamos en la dirección de la <strong>“segunda componente”</strong>, obtendremos las proyecciones siguientes (en color verde):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Figuras/cp3.png" class="lightbox" data-gallery="cp"><img src="Figuras/cp3.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></a></p>
</figure>
</div>
</section>
</section>
<section id="cálculo-de-las-componentes" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="cálculo-de-las-componentes"><span class="header-section-number">4.2</span> Cálculo de las componentes</h2>
<section id="cálculo-de-la-primera-componente" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="cálculo-de-la-primera-componente"><span class="header-section-number">4.2.1</span> Cálculo de la primera componente</h3>
<p>La primera componente principal se define como la combinación lineal de las variables originales que tiene varianza máxima. Los valores en esta primera componente de los <span class="math inline">\(n\)</span> individuos se representarán por un vector <span class="math inline">\(\mathbf{z_1}\)</span> dado por <span class="math display">\[\mathbf{z_1}=\mathbf{Xa_1}.\]</span> Si las variables originales tienen media cero, <span class="math inline">\(\mathbf{z_1}\)</span> también tendrá media nula. Su varianza será</p>
<p><span class="math display">\[\begin{equation} \tag{1}
Var(\mathbf{z_1})=\frac{1}{n}\mathbf{z_1^t}\mathbf{z_1}=\frac{1}{n}\mathbf{a_1^t X^t}\mathbf{Xa_1}=\mathbf{a_1^t S}\mathbf{a_1}
\end{equation}\]</span></p>
<p>donde <span class="math inline">\(\mathbf{S}\)</span> es la matriz de varianzas-covarianzas de las observaciones.</p>
<p>Es obvio que podemos maximizar la varianza tanto como queramos aumentando el módulo del vector <span class="math inline">\(\mathbf{a_1}\)</span>. Para que maximizar (1) tenga solución debemos imponer una restricción al módulo del vector <span class="math inline">\(\mathbf{a_1}\)</span>, y, sin pérdida de generalidad, impondremos que <span class="math inline">\(\mathbf{a_1^t}\mathbf{a_1}=1\)</span>. Introducimos esta restricción mediante el multiplicador de Lagrange: <span class="math display">\[M=\mathbf{a_1^t}S\mathbf{a_1}-\lambda(\mathbf{a_1^t}\mathbf{a_1}-1)\]</span> y maximizamos esta expresión derivando respecto a las componentes de <span class="math inline">\(\mathbf{a_1}\)</span> e igualando a cero. Entonces <span class="math display">\[\frac{\partial M}{\partial \mathbf{a_1}}=2\mathbf{Sa_1}-2 \lambda \mathbf{a_1}=0,\]</span></p>
<p>cuya solución es:</p>
<p><span class="math display">\[\begin{equation} \tag{2}
\mathbf{Sa_1}= \lambda \mathbf{a_1},
\end{equation}\]</span></p>
<p>que implica que <span class="math inline">\(\mathbf{a_1}\)</span> es un vector propio de la matriz <span class="math inline">\(\mathbf{S}\)</span>, y <span class="math inline">\(\lambda\)</span> su correspondiente valor propio.</p>
<p>Para determinar qué valor propio de <span class="math inline">\(\mathbf{S}\)</span> es la solución de (2), multiplicamos por la izquierda por <span class="math inline">\(\mathbf{a_1^t}\)</span> a esta ecuación,</p>
<p><span class="math display">\[\begin{equation}
\mathbf{a_1^t S a_1}= \lambda \mathbf{a_1^t a_1}= \lambda
\end{equation}\]</span></p>
<p>y <strong>concluimos, por (1) que <span class="math inline">\(\lambda\)</span> es la varianza de <span class="math inline">\(\mathbf{z_1}\)</span></strong>. Como esta es la cantidad que queremos maximizar, <span class="math inline">\(\lambda\)</span> será el mayor valor propio de la matriz <span class="math inline">\(\mathbf{S}\)</span>. Su vector asociado, <span class="math inline">\(\mathbf{a_1}\)</span>, define los coeficientes de cada variable en la primera componente principal.</p>
</section>
<section id="ejemplo" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="ejemplo"><span class="header-section-number">4.2.2</span> <span style="color: blue;"><em>Ejemplo:</em></span></h3>
<p>Calculad la primera componente principal con los logaritmos del fichero <code>acciones.txt</code> que podéis descargad en Aula Digital. Las observaciones corresponden a distintas acciones que cotizan en el mercado español y las variables son:</p>
<ul>
<li><code>V1</code> la rentabilidad efectiva por dividendos,</li>
<li><code>V2</code> la proporción de beneficios que va a dividendos</li>
<li><code>V3</code> el ratio entre precio por acción y beneficios.</li>
</ul>
<p>¿Cuál de las variables está mejor representada por la componente principal 1?</p>
<p><strong>Solución</strong></p>
<p>Cargamos los datos</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>datos<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="st">"datos/acciones.txt"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>n<span class="ot">=</span><span class="fu">dim</span>(datos)[<span class="dv">1</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>n</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 34</code></pre>
</div>
</div>
<p>La tabla presenta tres medidas de rentabilidad de 34 acciones en bolsa. Vamos a reescribirlas para ganar interpretabilidad. Llamamos <span class="math inline">\(d\)</span> a los dividendos por acción, <span class="math inline">\(p\)</span> al precio de la acción, <span class="math inline">\(B\)</span> al beneficio y <span class="math inline">\(N\)</span> al número de acciones. Entonces:</p>
<ul>
<li><p><code>V1</code> es la rentabilidad efectiva por dividendos, es decir, dividendos repartidos por acción divididos por precio de la acción. <span class="math inline">\(V1=\frac{d}{p}\)</span>.</p></li>
<li><p><code>V2</code> es la proporción de beneficios que va a dividendos. <span class="math inline">\(V2=\frac{dN}{B}\)</span>.</p></li>
<li><p><code>V3</code> es el cociente entre precio y beneficio por acción. <span class="math inline">\(V3=\frac{p}{B/N}=\frac{pN}{B}\)</span></p></li>
</ul>
<p>Exploramos los datos</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Las densidades indican un alejamiento de la distribución normal para las tres variables. Las dos primeras sugieren la presencia de dos grupos de datos distintos (acciones con comportamientos distintos), y la tercera tiene una densidad muy asimétrica, con al menos un valor atípico.</p>
<p>Por la forma de cálculo de las variables, es lógico esperar alta correlación positiva entre <code>V1</code> y <code>v2</code>. La correlación negativa baja entre <code>V1</code> y <code>v3</code>, así como alta negativa entre <code>V2</code> y<code>v3</code>.</p>
<p>Ahora, estimamos la matriz de varianzas-covarianzas de las variables originales <code>V1</code>, <code>v2</code> y <code>V3</code>, con el estimador sesgado:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>S0<span class="ot">=</span><span class="fu">round</span>(((n<span class="dv">-1</span>)<span class="sc">/</span>n)<span class="sc">*</span><span class="fu">cov</span>(datos),<span class="dv">2</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>S0</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       V1     V2     V3
V1  28.24  97.49 -15.24
V2  97.49 559.28 -18.00
V3 -15.24 -18.00  21.90</code></pre>
</div>
</div>
<p>Recordad que las densidades de las tres variables han mostrado una clara falta de normalidad y entre ellas hay relaciones no lineales. En estas condiciones, la matriz de varianzas-covarianzas no es un buen resumen de las relaciones de dependencia existentes.</p>
<p>Para tratar de resolver el problema anterior, podemos usar el logaritmo que es una de las transformaciones más utilizadas para datos positivos en los siguientes casos:</p>
<ol type="1">
<li><p>Los datos describen el tamaño de las cosas (renta de países o familias habitantes en las principales ciudades del mundo, tamaño de empresas, consumo de energía en hogares, etc), son generalmente muy asimétricas, pero se convierten en aproximadamente simétricas al expresar la variable en logaritmos.</p></li>
<li><p>Cuando las diferencias relativas entre los valores de la variable son importantes, conviene expresar las variables en logaritmos, ya que las diferencias entre logaritmos equivalen a diferencias relativas en la escala original.</p></li>
<li><p><strong>La variabilidad de las variables transformadas es independiente de las unidades de medida</strong>. Para mostrar esta propiedad, supongamos que tenemos una sola variable aleatoria <span class="math inline">\(X\)</span> que transformamos con <span class="math inline">\(Y = \log X\)</span>, la variable transformada tiene media <span class="math inline">\(\mu_Y\)</span> y varianza <span class="math inline">\(\sigma^2_Y\)</span>. Si cambiamos las unidades de medida de <span class="math inline">\(X\)</span> multiplicando por una constante, <span class="math inline">\(Z = kX\)</span>, entonces la variable <span class="math inline">\(\log Z\)</span> tiene media <span class="math inline">\(Y + \log k\)</span> y la misma varianza que la variable <span class="math inline">\(\log X\)</span>. Por tanto, <strong>al tomar logaritmos en las variables, las varianzas pueden compararse aunque los datos tengan distintas dimensiones</strong>.</p></li>
</ol>
<p>De acuerdo a los anterior, aplicamos una transformación logarítmica a nuestros datos, con lo cual, la matriz de varianzas-covarianzas de las variables transformadas, sería:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>datos_l<span class="ot">=</span><span class="fu">log</span>(datos)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>S<span class="ot">=</span><span class="fu">round</span>(((n<span class="dv">-1</span>)<span class="sc">/</span>n)<span class="sc">*</span><span class="fu">cov</span>(datos_l),<span class="dv">2</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>S</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      V1    V2    V3
V1  0.35  0.15 -0.19
V2  0.15  0.13 -0.03
V3 -0.19 -0.03  0.16</code></pre>
</div>
</div>
<p>Observad que los logaritmos modifican mucho los resultados. <strong>Los datos ahora son más homogéneos</strong> y la variable de mayor varianza pasa a ser la primera, el logaritmo de la rentabilidad efectiva, mientras que la menor es la segunda, el logaritmo de la proporción de beneficios que va a dividendos. La relación entre el logaritmo del ratio precio/beneficios y la rentabilidad efectiva es negativa. Las otras relaciones son débiles.</p>
<p>Calculamos los valores propios de la matriz de varianzas covarianzas de los datos transformados que son las raíces de la ecuación</p>
<p><span class="math display">\[
\begin{equation}
\begin{split}
|S-\lambda I| &amp; =  \left| \begin{pmatrix}0.35 &amp; 0.15 &amp; -0.19\\ 0.15 &amp; 0.13 &amp; -0.03 \\ -0.19 &amp; -0.03 &amp; 0.16\end{pmatrix} -\begin{pmatrix} \lambda &amp; 0 &amp; 0\\ 0 &amp; \lambda &amp; 0 \\ 0 &amp; 0 &amp; \lambda\end{pmatrix}  \right| \\ \\
&amp; = 0.000382-0.0628\lambda+0.64 \lambda^2 -\lambda^3 =0
\end{split}
\end{equation}
\]</span></p>
<p>Buscamos las raíces de este polinomio son</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(polynom)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>p<span class="ot">=</span><span class="fu">polynomial</span>(<span class="at">coef=</span><span class="fu">c</span>(<span class="fl">0.00038</span>,<span class="sc">-</span><span class="fl">0.0628</span>,<span class="fl">0.64</span>,<span class="sc">-</span><span class="dv">1</span>))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>raices<span class="ot">=</span><span class="fu">round</span>(<span class="fu">solve</span>(p),<span class="dv">3</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Las raíces son <span class="math inline">\(\lambda_1\)</span>=0.521, <span class="math inline">\(\lambda_2\)</span>=0.113 y <span class="math inline">\(\lambda_3\)</span>=0.006.</p>
<p>El vector propio asociado a <span class="math inline">\(lambda_1\)</span> nos da los pesos de la primera componente principal. Para calcularlo manualmente, debemos resolver el sistema <span class="math display">\[S \mathbf{a_1}= \lambda_1 \mathbf{a_1}\]</span> que conduce a</p>
<p><span class="math display">\[
\begin{equation}
\begin{split}
\begin{pmatrix}0.35 &amp; 0.15 &amp; -0.19\\ 0.15 &amp; 0.13 &amp; -0.03 \\ -0.19 &amp; -0.03 &amp; 0.16\end{pmatrix} \begin{pmatrix} a_{11} \\a_{12} \\ a_{131} \end{pmatrix} &amp;=0.521 \cdot \begin{pmatrix} a_{11} \\a_{12} \\ a_{131} \end{pmatrix}
\end{split}
\end{equation}
\]</span> <span class="math display">\[
\begin{equation}
\begin{split}
\begin{pmatrix}-0.171 a_{11}+0.15 a_{12} -0.19 a_{13} \\ 0.15 a_{11}-0.391 a_{12} -0.03 a_{13}\\ -0.19 a_{11}-0.03 a_{12} -0.361 a_{13}\end{pmatrix}  &amp;= \begin{pmatrix} 0 \\0 \\ 0 \end{pmatrix}
\end{split}
\end{equation}
\]</span> Este sistema es compatible indeterminado. Para encontrar una de las infinitas soluciones tomemos la primera variable como parámetro, <span class="math inline">\(x\)</span>, y resolvemos el sistema en función de <span class="math inline">\(x\)</span>. La solución es,</p>
<p><span class="math display">\[\{a_{11}=x,\; a_{12}=0.427x,\; a_{13}=-0.562x\]</span></p>
<p>El valor de <span class="math inline">\(x\)</span> lo obtenemos imponiendo que el vector tenga norma uno, con lo que resulta:</p>
<p><span class="math display">\[\mathbf{a_1}=\begin{pmatrix} -0.817 \\-0.349 \\ 0.459 \end{pmatrix}\]</span></p>
<p>Por lo tanto, la primera componente es <span class="math display">\[Z_1=-0.817 \log(d/p)-0.349 \log(dN/p)+0.459 \log(pN/B)\]</span></p>
<p>que indica que este primer componente depende básicamente de la rentabilidad por dividendos. Esta variable es la que mejor explica la variabilidad conjunta de las acciones.</p>
</section>
<section id="cálculo-de-la-segunda-componente" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="cálculo-de-la-segunda-componente"><span class="header-section-number">4.2.3</span> Cálculo de la segunda componente</h3>
<p>Vamos a obtener el mejor plano de proyección de l matriz <span class="math inline">\(\mathbf{X}\)</span>. Lo calcularemos estableciendo como función objetivo que la suma de las varianzas de <span class="math inline">\(\mathbf{z_1}=\mathbf{Xa_1}\)</span> y <span class="math inline">\(\mathbf{z_2}=\mathbf{Xa_2}\)</span> sean máximas, donde <span class="math inline">\(\mathbf{a_1}\)</span> y <span class="math inline">\(\mathbf{a_2}\)</span> son los vectores que definen el plano. La función objetivo será:</p>
<p><span class="math display">\[\begin{equation} \tag{3}
\phi=\mathbf{a_1^t S}\mathbf{a_1} + \mathbf{a_2^t S}\mathbf{a_2} - \lambda_1 (\mathbf{a_1^t}\mathbf{a_1}-1) - \lambda_2 (\mathbf{a_2^t}\mathbf{a_2}-1)
\end{equation}\]</span></p>
<p>que incorpora las restricciones de que las direcciones deben de tener módulo unitario. Derivando e igualando a cero: <span class="math display">\[\frac{\partial \phi}{\partial \mathbf{a_1}}=2\mathbf{Sa_1}-2 \lambda_1 \mathbf{a_1}=0\]</span></p>
<p><span class="math display">\[\frac{\partial \phi}{\partial \mathbf{a_2}}=2\mathbf{Sa_2}-2 \lambda_2 \mathbf{a_1}=0\]</span></p>
<p>La solución del sistema es: <span class="math display">\[\begin{equation} \tag{4}
\mathbf{Sa_1}= \lambda \mathbf{a_1},
\end{equation}\]</span> <span class="math display">\[\begin{equation} \tag{5}
\mathbf{Sa_2}= \lambda \mathbf{a_2},
\end{equation}\]</span></p>
<p>que indica que <span class="math inline">\(\mathbf{a_1}\)</span> y <span class="math inline">\(\mathbf{a_2}\)</span> deben ser vectores propios de <span class="math inline">\(\mathbf{S}\)</span>.</p>
<p>Tomando los vectores propios de norma uno y sustituyendo en (3), se obtiene que, en el máximo, la función objetivo es <span class="math display">\[\begin{equation} \tag{6}
\phi=\lambda_1+\lambda_2
\end{equation}\]</span></p>
<p>es claro que <span class="math inline">\(\lambda_1\)</span> y <span class="math inline">\(\lambda_2\)</span> deben ser los dos valores propios mayores de la matriz <span class="math inline">\(\mathbf{S}\)</span> y <span class="math inline">\(\mathbf{a_1}\)</span> y <span class="math inline">\(\mathbf{a_2}\)</span> sus correspondientes vectores propios.</p>
<p>Observad que la covarianza entre <span class="math inline">\(\mathbf{z_1}\)</span> y <span class="math inline">\(\mathbf{z_2}\)</span>, dada por <span class="math inline">\(\mathbf{a_1^t S a_2}\)</span> es cero ya que =0, y las variables<span class="math inline">\(\mathbf{z_1}\)</span> y <span class="math inline">\(\mathbf{z_2}\)</span> estarán incorreladas.</p>
<p>Se puede demostrarse que si en lugar de maximizar la suma de varianzas, que es la traza de la matriz de covarianzas de la proyección, se maximiza la varianza generalizada (el determinante de la matriz de covarianzas) se obtiene el mismo resultado.</p>
<section id="generalización" class="level4" data-number="4.2.3.1">
<h4 data-number="4.2.3.1" class="anchored" data-anchor-id="generalización"><span class="header-section-number">4.2.3.1</span> Generalización</h4>
<p>Análogamente, el espacio de dimensión <span class="math inline">\(r\)</span> que mejor representa a los puntos viene definido por los vectores propios asociados a los <span class="math inline">\(r\)</span> mayores valores propios de <span class="math inline">\(\mathbf{S}\)</span>. Estas direcciones se denominan direcciones principales de los datos y a las nuevas variables por ellas definidas componentes principales. En general, la matriz <span class="math inline">\(\mathbf{X}\)</span> (y por tanto la <span class="math inline">\(\mathbf{S}\)</span>) tiene rango <span class="math inline">\(p\)</span>, existiendo entonces tantas componentes principales como variables que se obtendrán calculando los valores propios o raíces características, <span class="math inline">\(\lambda_1, \ldots, \lambda_p\)</span>, de la matriz de varianzas y covarianzas de las variables, <span class="math inline">\(\mathbf{S}\)</span> , mediante:</p>
<p><span class="math display">\[\begin{equation} \tag{7}
|\mathbf{S}-\lambda\mathbf{I}|=0
\end{equation}\]</span></p>
<p>y sus vectores asociados son: <span class="math display">\[\begin{equation} \tag{8}
(\mathbf{S}-\lambda_i\mathbf{I})\mathbf{a_i}=0.
\end{equation}\]</span></p>
<p>Los términos <span class="math inline">\(\lambda_i\)</span> son reales, al ser la matriz <span class="math inline">\(\mathbf{S}\)</span> simétrica, y positivos, ya que <span class="math inline">\(\mathbf{S}\)</span> es definida positiva.</p>
<p>Por ser <span class="math inline">\(\mathbf{S}\)</span> simétrica si <span class="math inline">\(\lambda_j\)</span> y <span class="math inline">\(\lambda_h\)</span> son dos raíces distintas sus vectores asociados son ortogonales.</p>
<p>Si <span class="math inline">\(\mathbf{S}\)</span> fuese semidefinida positiva de rango <span class="math inline">\(r &lt; p\)</span>, lo que ocurriría si <span class="math inline">\(p−r\)</span> variables fuesen combinación lineal de las demás, habría solamente <span class="math inline">\(r\)</span> raíces características positivas y el resto serían ceros.</p>
<p>Llamando <span class="math inline">\(\mathbf{Z}\)</span> a la matriz cuyas columnas son los valores de las <span class="math inline">\(p\)</span> componentes en los <span class="math inline">\(n\)</span> individuos, estas nuevas variables están relacionadas con las originales mediante:</p>
<p><span class="math display">\[\begin{equation} \tag{9}
\mathbf{Z}=\mathbf{X}\mathbf{A}
\end{equation}\]</span></p>
<p>donde <span class="math inline">\(\mathbf{A^t A}=\mathbf{I}\)</span>. Calcular las componentes principales equivale a aplicar una transformación ortogonal <span class="math inline">\(\mathbf{A}\)</span> a las variables <span class="math inline">\(\mathbf{X}\)</span> (ejes originales) para obtener unas nuevas variables <span class="math inline">\(\mathbf{Z}\)</span> incorreladas entre sí. Esta operación puede interpretarse como elegir unos nuevos ejes coordenados, que coincidan con los “ejes naturales” de los datos.</p>
</section>
<section id="ejemplo-1" class="level4" data-number="4.2.3.2">
<h4 data-number="4.2.3.2" class="anchored" data-anchor-id="ejemplo-1"><span class="header-section-number">4.2.3.2</span> <span style="color: blue;"><em>Ejemplo:</em></span></h4>
<p>Vamos a realizar el análisis de componentes principales (PCA) sobre el conjunto de datos de las acciones del mercado español, esta vez utilizando a R para calcular los valores y vectores propios.</p>
<p>Recordad que ya hemos calculado la matriz de varianzas-covarianzas muestral sesgada de los datos transformados, <span class="math inline">\(S\)</span>=0.35, 0.15, -0.19, 0.15, 0.13, -0.03, -0.19, -0.03, 0.16.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>sol<span class="ot">=</span><span class="fu">eigen</span>(S)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los valores propios son:</p>
<p><span class="math display">\[\lambda_1=0.521,\quad \lambda_2=0.113,\quad \lambda_3 = 0.007.\]</span></p>
<ul>
<li>Los vectores propios ortonormales correspondientes a los valores propios, son los que aparecen con el nombre: <code>$vectors</code></li>
</ul>
<p>Las expresiones de las variables nuevas <span class="math inline">\(CP_i\)</span> en función de los logaritmos de las originales son:</p>
<p><span class="math display">\[\begin{array}{rl}
Z_1 = &amp; 0.817 \cdot \log V_1 + 0.349\cdot \log V_2 - 0.459 \cdot \log V_3, \\
Z_2 = &amp; 0.043 \cdot \log V_1 + 0.758\cdot \log V_2 + 0.651 \cdot \log V_3, \\
Z_3 = &amp; 0.575 \cdot \log V_1 - 0.552 \cdot \log V_2 + 0.604 \cdot \log V_3, \\
\end{array}\]</span></p>
<p>La nueva matriz de datos respecto de las componentes principales será:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>X<span class="ot">=</span><span class="fu">matrix</span>(<span class="fu">c</span>(datos_l<span class="sc">$</span>V1,datos_l<span class="sc">$</span>V2,datos_l<span class="sc">$</span>V3),<span class="at">nrow=</span><span class="dv">34</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>Z<span class="ot">=</span>X <span class="sc">%*%</span> sol<span class="sc">$</span>vectors <span class="co"># Z=XA  con A la matriz de vectores propios</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(Z)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         [,1]     [,2]       [,3]
[1,] 1.003343 5.678343 0.28103506
[2,] 1.680545 4.608193 0.10346897
[3,] 1.487526 4.652723 0.15673341
[4,] 1.257073 4.543832 0.05520223
[5,] 1.866053 4.187286 0.12455276
[6,] 1.637393 3.919281 0.21592221</code></pre>
</div>
</div>
<p>Si representamos gráficamente las dos primeras componentes, podemos observar que se puede distinguir entre los dos grupos de acciones.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Z[,<span class="dv">1</span>],Z[,<span class="dv">2</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>¿Qué hubiese pasado si centramos los datos?</strong></p>
<p>Aunque no es obligatorio centrar la matriz de datos para PCA, es una práctica común y recomendada, ya que ayuda a garantizar que las componentes principales reflejen de manera más precisa la estructura de variabilidad en los datos.</p>
<p>Si no se centran los datos, la primera componente principal estaría influenciada por la ubicación de los datos en el espacio original, es decir, por la media de los datos. En nuestro ejemplo, esto está minimizado por el efecto de la transformación logarítmica.</p>
<p>Veamos los resultados centrando los datos</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">colMeans</span>(X)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.071865 4.178913 2.117252</code></pre>
</div>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>Hn<span class="ot">=</span><span class="fu">diag</span>(n)<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span>n <span class="co"># matriz de centrado</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>cX<span class="ot">=</span>Hn<span class="sc">%*%</span>X <span class="co"># matriz centrada</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(cX,<span class="dv">3</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        [,1]   [,2]   [,3]
 [1,] -0.848  0.318  1.291
 [2,] -0.443 -0.159  0.175
 [3,] -0.568 -0.222  0.325
 [4,] -0.819 -0.329  0.299
 [5,] -0.297 -0.425 -0.171
 [6,] -0.443 -0.758 -0.186
 [7,] -0.546 -0.014  0.351
 [8,] -0.462 -0.247  0.145
 [9,] -0.909 -0.183  0.571
[10,] -0.848 -0.357  0.463
[11,] -0.200 -0.493 -0.469
[12,] -0.590 -0.483  0.500
[13,] -0.443 -0.220  0.281
[14,] -0.314 -0.397 -0.038
[15,] -0.546 -0.212  0.550
[16,] -0.098  0.008 -0.063
[17,] -0.098 -0.117 -0.076
[18,] -0.590 -0.110  0.376
[19,] -0.018  0.255  0.281
[20,]  0.701  0.391 -0.325
[21,]  0.744  0.426 -0.200
[22,]  0.649  0.346 -0.469
[23,]  0.790  0.425 -0.200
[24,]  0.713  0.359 -0.309
[25,]  0.616  0.426 -0.230
[26,]  0.656  0.425 -0.342
[27,]  0.688  0.426 -0.186
[28,]  0.835  0.389 -0.377
[29,]  0.694  0.426 -0.309
[30,]  0.707  0.348 -0.309
[31,]  0.200  0.294 -0.076
[32,] -0.140 -0.197 -0.230
[33,]  0.595  0.296 -0.469
[34,]  0.629 -0.638 -0.572</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>Sc<span class="ot">&lt;-</span>(<span class="dv">1</span><span class="sc">/</span>n)<span class="sc">*</span><span class="fu">t</span>(cX)<span class="sc">%*%</span>Hn<span class="sc">%*%</span>cX <span class="co"># estimador sesgado de la matriz de covarianza</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(Sc,<span class="dv">3</span>) <span class="co"># daría igual cov(cX)*(n-1)/n</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       [,1]   [,2]   [,3]
[1,]  0.352  0.147 -0.188
[2,]  0.147  0.131 -0.031
[3,] -0.188 -0.031  0.158</code></pre>
</div>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>solc<span class="ot">&lt;-</span><span class="fu">eigen</span>(Sc)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>Zc<span class="ot">=</span>cX <span class="sc">%*%</span> solc<span class="sc">$</span>vectors </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Zc[,<span class="dv">1</span>],Zc[,<span class="dv">2</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="propiedades-del-acp" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="propiedades-del-acp"><span class="header-section-number">4.3</span> Propiedades del ACP</h2>
<section id="acp-con-la-matriz-de-covarianzas" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="acp-con-la-matriz-de-covarianzas"><span class="header-section-number">4.3.1</span> ACP con la matriz de covarianzas</h3>
<p>Los componentes principales como nuevas variables tienen las propiedades siguientes:</p>
<ol type="1">
<li><p>Las componentes principales reproducen la varianza total. <span class="math display">\[\sum_{i=1}^p Var(\mathbf{Z}_i)=\sum_{i=1}^p \lambda_i=tr(\mathbf{S})=\sum_{i=1}^p s_i^2\]</span>.</p></li>
<li><p>Los componentes principales tienen correlación cero entre sí (son <em>incorrelados</em>) por lo tanto su matriz de covarianzas es</p></li>
</ol>
<p><span class="math display">\[\mathbf{S}_{Z}=\left(\begin{array}{cccc}
\lambda_1&amp; 0 &amp;\ldots &amp;0\\
0&amp; \lambda_{2}&amp;\ldots &amp; 0\\
\vdots &amp; \vdots &amp; &amp; \vdots\\
0 &amp; 0&amp;\ldots &amp;\lambda_{p}
\end{array}
\right)\]</span></p>
<p><span class="math inline">\(\det(\mathbf{S}_{Z})=\prod_{i=1}^p \lambda_i =\det(\mathbf{S})\)</span>. Luego los componentes principales conservan la varianza generalizada.</p>
<ol start="2" type="1">
<li>La proporción de varianza explicada por la componente <span class="math inline">\(j\)</span>-ésima es <span class="math display">\[\frac{\lambda_j}{\sum_{i=1}^p \lambda_i}.\]</span></li>
</ol>
<p>Además al ser <em>incorrelados</em> la proporción de varianza explicada por los <span class="math inline">\(k\)</span> primeros componentes es <span class="math display">\[\frac{\sum_{i=1}^k \lambda_i}{\sum_{i=1}^p \lambda_i}.\]</span> <br></p>
<p><span class="math inline">\(\mbox{Cov}(\tilde{\mathbf{X}}_i, \mathbf{Z}_j)=\frac{\sqrt{\lambda_j} a_{j i}}{s_i}\)</span>, donde <span class="math inline">\(a_{j i}\)</span> es la <span class="math inline">\(i\)</span>-ésima componente del vector propio <span class="math inline">\(\mathbf{a}_j\)</span>.</p>
</section>
<section id="acp-normado-o-con-matriz-de-correlaciones" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="acp-normado-o-con-matriz-de-correlaciones"><span class="header-section-number">4.3.2</span> ACP normado o con matriz de correlaciones</h3>
<p>Las componentes principales se obtienen maximizando la varianza de la proyección. En términos de las variables originales esto supone maximizar:</p>
<p><span class="math display">\[M=\displaystyle \sum_{i=1}^p a_i^2s_i^2+ 2 \displaystyle \sum_{i=1}^p  \displaystyle \sum_{j=i+1}^p a_i a_j s_{ij}\]</span> con la restricción <span class="math inline">\(\mathbf{a^ta}=1\)</span>. Si alguna de las variables, por ejemplo la primera, tiene una varianza <span class="math inline">\(s^2_1\)</span>, mayor que las demás, la manera de aumentar <span class="math inline">\(M\)</span> es hacer tan grande como podamos la coordenada <span class="math inline">\(a_1\)</span> asociada a esta variable. En el límite si una variable tiene una varianza mucho mayor que las demás el primer componente principal coincidirá muy aproximadamente con esta variable.</p>
<p>Cuando las variables tienen unidades distintas esta propiedad no es conveniente: si disminuimos la escala de medida de una variable cualquiera, de manera que aumenten en magnitud sus valores numéricos (pasamos por ejemplo de medir en km. a medir en metros), el peso de esa variable en el análisis aumentará, ya que en la ecuación anterior:</p>
<ol type="1">
<li><p>su varianza será mayor y aumentará su coeficiente en el componente, <span class="math inline">\(a_1\)</span>, ya que contribuye más a aumentar M;</p></li>
<li><p>sus covarianzas con todas las variables aumentarán, con el consiguiente efecto de incrementar <span class="math inline">\(a_i\)</span>.</p></li>
</ol>
<p>En resumen, <strong>cuando las escalas de medida de las variables son muy distintas, la maximización de <span class="math inline">\(M\)</span> dependerá decisivamente de estas escalas de medida y las variables con valores más grandes tendrán más peso en el análisis.</strong></p>
<p>Si queremos evitar este problema, <strong>conviene estandarizar las variables antes de calcular los componentes, de manera que las magnitudes de los valores numéricos de las variables <span class="math inline">\(X\)</span> sean similares.</strong></p>
<p>La estandarización resuelve otro posible problema. Si las variabilidades de la <span class="math inline">\(X\)</span> son muy distintas, las variables con mayor varianza van a influir más en la determinación de la primera componente. Este problema se evita al estandarizar las variables, ya que entonces las varianzas son la unidad, y las covarianzas son los coeficientes de correlación. La ecuación a maximizar se transforma en:</p>
<p><span class="math display">\[M'=1 + 2 \displaystyle \sum_{i=1}^p  \displaystyle \sum_{j=i+1}^p a_i a_j r_{ij}\]</span> siendo <span class="math inline">\(r_{ij}\)</span> el coeficiente de correlación lineal entre las variables <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>. En consecuencia la solución depende de la correlaciones y no de las varianzas.</p>
<p><strong>Las componentes principales normados se obtiene calculando los vectores y valores propios de la matriz R, de coeficientes de correlación</strong>. Llamando <span class="math inline">\(\lambda_p^R\)</span> a las raíces características de esa matriz, que suponemos no singular, se verifica que: <span class="math display">\[{\sum_{i=1}^p \lambda_i^R}=traza(R)=p\]</span> Las propiedades de las componentes extraídos de <span class="math inline">\(R\)</span> son:</p>
<ol type="1">
<li><p>La proporción de variación explicada por <span class="math inline">\(\lambda_p^R\)</span> será <span class="math inline">\(\frac{\lambda_p^R}{p}\)</span>.</p></li>
<li><p>Las correlaciones entre cada componente <span class="math inline">\(z_j\)</span> y las variables <span class="math inline">\(X\)</span> originales vienen dadas directamente por <span class="math inline">\(a^t_j \sqrt{\lambda_j}\)</span>, siendo <span class="math inline">\(\mathbf{z_j}=\mathbf{Xa_j}\)</span>.</p></li>
</ol>
<p>Estas propiedades son consecuencia inmediata de los resultados de la sección anterior.</p>
<ul>
<li><p><strong>Cuando las variables X originales están en distintas unidades conviene aplicar el análisis de la matriz de correlaciones o análisis normado</strong>.</p></li>
<li><p>Cuando las variables tienen las mismas unidades, ambas alternativas son posibles.</p></li>
<li><p>Si las diferencias entre las varianzas de las variables son informativas y queremos tenerlas en cuenta en el análisis no debemos estandarizar las variables: por ejemplo, supongamos dos índices con la misma base pero uno fluctua mucho y el otro es casi constante. Este hecho es informativo, y para tenerlo en cuenta en el análisis, no se deben estandarizar las variables, de manera que el índice de mayor variabilidad tenga más peso. Por el contrario, si las diferencias de variabilidad no son relevantes podemos eliminarlas con el análisis normado. En caso de duda, conviene realizar ambos análisis, y seleccionar aquel que conduzca a conclusiones más informativas.</p></li>
</ul>
</section>
</section>
<section id="análisis-de-componentes-principales-en-r" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="análisis-de-componentes-principales-en-r"><span class="header-section-number">4.4</span> Análisis de Componentes Principales en R</h2>
<p>Vamos a explicar las funciones de R para hacer el PCA, para ello utilizaremos los famosos datos de las flores iris.</p>
<p align="center">
</p><p><img src="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Machine+Learning+R/iris-machinelearning.png" class="img-fluid" style="width:70.0%"></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(iris,<span class="dv">2</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa</code></pre>
</div>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(iris,<span class="dv">2</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
149          6.2         3.4          5.4         2.3 virginica
150          5.9         3.0          5.1         1.8 virginica</code></pre>
</div>
</div>
<p>Lo primero que hacemos es revisar si las variables están correlacionadas, requisito necesario para obtener una representación más simple de éstas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cov</span>(iris[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length    0.6856935  -0.0424340    1.2743154   0.5162707
Sepal.Width    -0.0424340   0.1899794   -0.3296564  -0.1216394
Petal.Length    1.2743154  -0.3296564    3.1162779   1.2956094
Petal.Width     0.5162707  -0.1216394    1.2956094   0.5810063</code></pre>
</div>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(iris[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length    1.0000000  -0.1175698    0.8717538   0.8179411
Sepal.Width    -0.1175698   1.0000000   -0.4284401  -0.3661259
Petal.Length    0.8717538  -0.4284401    1.0000000   0.9628654
Petal.Width     0.8179411  -0.3661259    0.9628654   1.0000000</code></pre>
</div>
</div>
<p>Comparamos las funciones de R para hacer el PCA</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Figuras/prcomp_princomp.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>Calculamos las componentes con los datos escalados con la librería <code>factoextra</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"factoextra"</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>iris.acp<span class="ot">=</span><span class="fu">prcomp</span>(iris[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], <span class="at">scale =</span> <span class="cn">TRUE</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los valores propios muestran el porcentaje de varianza explicada por cada componente principal.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>lambdas<span class="ot">=</span><span class="fu">get_eigenvalue</span>(iris.acp)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>lambdas</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      eigenvalue variance.percent cumulative.variance.percent
Dim.1 2.91849782       72.9624454                    72.96245
Dim.2 0.91403047       22.8507618                    95.81321
Dim.3 0.14675688        3.6689219                    99.48213
Dim.4 0.02071484        0.5178709                   100.00000</code></pre>
</div>
</div>
<p>Observamos que las dos primeras componentes principales explican aproximadamente el 96% de la variación total. Puede ser razonable, trabajar con esas dos componentes para el análisis posterior de estos datos.</p>
<p>Un método alternativo para determinar el número de componentes principales es observar el diagrama de valores propios ordenados de mayor a menor. El número de componentes se determina en el punto, más allá del cual los valores propios restantes son todos relativamente pequeños y de tamaño comparable.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_eig</span>(iris.acp, <span class="at">addlabels =</span> <span class="cn">TRUE</span>, <span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">100</span>))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-17-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>La representación de variables difiere de la gráfica de las observaciones: Las observaciones están representadas por sus proyecciones, pero las variables están representados por sus correlaciones.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_pca_var</span>(iris.acp, <span class="at">col.var =</span> <span class="st">"contrib"</span>,</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">gradient.cols =</span> <span class="fu">c</span>(<span class="st">"#00AFBB"</span>, <span class="st">"#E7B800"</span>, <span class="st">"#FC4E07"</span>),</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">repel =</span> <span class="cn">TRUE</span>) </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>El gráfico anterior también se conoce como círculo de correlación variable. Muestra las relaciones entre todas las variables. Se puede interpretar de la siguiente manera:</p>
<ul>
<li><p>Las variables correlacionadas positivamente se agrupan.</p></li>
<li><p>Las variables correlacionadas negativamente se colocan en lados opuestos del origen de la trama (cuadrantes opuestos).</p></li>
<li><p>La distancia entre variables y el origen mide la calidad de la representación de las variables, las que están alejadas del origen están bien representadas.</p></li>
</ul>
<p>La calidad de representación de las variables se llama cos2 (coseno cuadrado, coordenadas cuadradas). Es posible crear un diagrama de barras de las variables <code>cos2</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>var <span class="ot">&lt;-</span> <span class="fu">get_pca_var</span>(iris.acp)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_cos2</span>(iris.acp, <span class="at">choice =</span> <span class="st">"var"</span>, <span class="at">axes =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li><p>Un cos2 alto indica una buena representación de la variable en el componente principal. En este caso, la variable se coloca cerca de la circunferencia del círculo de correlación.</p></li>
<li><p>Un cos2 bajo indica que la variable no está perfectamente representada por los PC. En este caso, la variable está cerca del centro del círculo.</p></li>
</ul>
<p>Para ver como se relacionan las componentes principales con los datos originales, veamos los autovectores.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>iris.acp<span class="sc">$</span>rotation</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                    PC1         PC2        PC3        PC4
Sepal.Length  0.5210659 -0.37741762  0.7195664  0.2612863
Sepal.Width  -0.2693474 -0.92329566 -0.2443818 -0.1235096
Petal.Length  0.5804131 -0.02449161 -0.1421264 -0.8014492
Petal.Width   0.5648565 -0.06694199 -0.6342727  0.5235971</code></pre>
</div>
</div>
<p>La primera componente principal da aproximadamente el mismo peso a la longitud del sépalo, la longitud del pétalo y el ancho del pétalo, pero da peso de signo contrario al ancho del sépalo.</p>
<p>La segunda componente principal se refiere principalmente al sépalo.</p>
<p>El biplot es un gráfico que permite representar las variables originales y las observaciones transformadas en los ejes de componentes principales.</p>
<ul>
<li><p>Cada flecha corresponde a una variable.</p></li>
<li><p>Nos fijamos primeramente en las direcciones de las flechas y su sentido.</p></li>
<li><p>Dos flechas que apunten al mismo lugar indica correlación alta.</p></li>
<li><p>Dos flechas con sentidos diferentes pero en la misma dirección indican una correlación negativa.</p></li>
<li><p>Cuando dos variables no están correladas en absoluto, se observan dos flechas apuntando en direcciones totalmente perpendiculares.</p></li>
<li><p>En cuanto a la diferencia en la longitud de las flechas, una menos larga informa que su variable está peor representada que una de largo mayor. Es una forma de medir la calidad de representación.</p></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_pca_biplot</span>(iris.acp, <span class="at">repel =</span> <span class="cn">TRUE</span>,</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">col.var =</span> <span class="st">"#2E9FDF"</span>, <span class="co"># color para las variables</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">col.ind =</span> <span class="st">"#696969"</span>  <span class="co"># color para las observaciones</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>                )</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-21-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>En el gráfico anterior podemos observar lo siguiente:</p>
<ul>
<li><p>Todas las variables originales tienen influencia en las componentes principales (lo cual se evidencia en el tamaño de las flechas).</p></li>
<li><p>La flecha más larga corresponde al ancho del sépalo, ya que tiene una fuerte influencia (loading) sobre la segunda componente.</p></li>
<li><p>La dirección de esta última flecha indica que el “loading” del ancho del sépalo para la primera componente es negativo.</p></li>
<li><p>Los “loadings” de las variables longitud del pétalo y ancho del pétalo con respecto a la segunda componente son muy bajos (las flechas son prácticamente horizontales).</p></li>
<li><p>La variable longitud del sépalo tiene loadings relativamente altos en las dos componentes principales.</p></li>
</ul>
<p><strong>Acceso a los resultados del ACP</strong></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Resultados por Variables</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>res.var<span class="ot">=</span><span class="fu">get_pca_var</span>(iris.acp)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>res.var<span class="sc">$</span>contrib        <span class="co"># Contribuciones a las CP </span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                 Dim.1       Dim.2     Dim.3     Dim.4
Sepal.Length 27.150969 14.24440565 51.777574  6.827052
Sepal.Width   7.254804 85.24748749  5.972245  1.525463
Petal.Length 33.687936  0.05998389  2.019990 64.232089
Petal.Width  31.906291  0.44812296 40.230191 27.415396</code></pre>
</div>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>res.var<span class="sc">$</span>cos2           <span class="co"># Calidad de la representación</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                 Dim.1       Dim.2       Dim.3        Dim.4
Sepal.Length 0.7924004 0.130198208 0.075987149 0.0014142127
Sepal.Width  0.2117313 0.779188012 0.008764681 0.0003159971
Petal.Length 0.9831817 0.000548271 0.002964475 0.0133055723
Petal.Width  0.9311844 0.004095980 0.059040571 0.0056790544</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Resultados por observaciones</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>res.obs<span class="ot">=</span><span class="fu">get_pca_ind</span>(iris.acp)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(res.obs<span class="sc">$</span>coord,<span class="dv">3</span>)  <span class="co">#Coordenadas</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      Dim.1      Dim.2      Dim.3      Dim.4
1 -2.257141 -0.4784238  0.1272796 0.02408751
2 -2.074013  0.6718827  0.2338255 0.10266284
3 -2.356335  0.3407664 -0.0440539 0.02828231</code></pre>
</div>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(res.obs<span class="sc">$</span>contrib,<span class="dv">3</span>)  <span class="co">#Contribuciones a las CP</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Dim.1      Dim.2       Dim.3      Dim.4
1 1.163769 0.16694510 0.073591567 0.01867287
2 0.982590 0.32925696 0.248367113 0.33919842
3 1.268304 0.08469576 0.008816151 0.02574286</code></pre>
</div>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(res.obs<span class="sc">$</span>cos2,<span class="dv">3</span>)  <span class="co"># Calidad de la representación</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      Dim.1      Dim.2        Dim.3        Dim.4
1 0.9539975 0.04286032 0.0030335249 0.0001086460
2 0.8927725 0.09369248 0.0113475382 0.0021874817
3 0.9790410 0.02047578 0.0003422122 0.0001410446</code></pre>
</div>
</div>
<p><strong>¿Qué tan bien lo hace el ACP?</strong></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggfortify"</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(iris.acp, <span class="at">data =</span> iris, <span class="at">colour =</span> <span class="st">'Species'</span>,</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">loadings =</span> <span class="cn">TRUE</span>, <span class="at">loadings.colour =</span> <span class="st">'blue'</span>,</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">loadings.label =</span> <span class="cn">TRUE</span>, <span class="at">loadings.label.size =</span> <span class="dv">3</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-24-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<section id="ejercicio" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="ejercicio"><span class="header-section-number">4.4.1</span> Ejercicio:</h3>
<p>Considera los datos <code>europa.dat</code> que están disponibles en Aula Digital. Los datos corresponden a los porcentajes de población empleados en diferentes actividades económicas en Europa para el año 1979. Las variables consideradas son: Agricultura, Minas, Fábricas, Suministro Eléctrico, Construcción, Industrias de Servicio, Finanzas, Servicios Sociales y Personales y, Transporte y Comunicaciones. Utiliza el método de componentes principales para reducir el número de variables, y tratar de determinar grupos de países con comportamientos semejantes en la distribución de su fuerza de trabajo. En este caso, usa la matriz de covarianza para el cálculo de las componentes principales, ya que todos los datos están medidos en la misma escala (porcentaje de la población) y por las caractersticas de los datos, no parece una buena idea considerarlos todos de igual manera.</p>
</section>
</section>
<section id="escalamiento-multidimensional-mds" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="escalamiento-multidimensional-mds"><span class="header-section-number">4.5</span> Escalamiento multidimensional (MDS)</h2>
<p>Las técnicas de escalado multidimensional son una generalización de la idea de componentes principales cuando en lugar de disponer de una matriz de observaciones por variables, como en componentes principales, se dispone de una matriz, <span class="math inline">\(\mathbf{D}\)</span>, cuadrada <span class="math inline">\(n \times n\)</span> de distancias o disimilaridades entre los <span class="math inline">\(n\)</span> elementos de un conjunto.</p>
<p>Estas distancias pueden haberse obtenido a partir de ciertas variables, o pueden ser el resultado de una estimación directa, por ejemplo preguntando a un grupo de evaluadores por sus opiniones sobre las similaridades entre los elementos considerados.</p>
<p>El objetivo del <span class="math inline">\(MDS\)</span> es representar las distancias observadas mediante unas variables con dimensión menor a <span class="math inline">\(n\)</span>, tales que las distancias euclideanas entre las coordenadas de los elementos respecto a estas variables sean iguales (o lo más próximas posibles) a las distancias o disimilaridades de la matriz partida. De esta manera, la representación gráfica en menor dimensión será una reproducción fiel de la estructura observada.</p>
<p>El escalado multidimensional comparte con componentes principales el objetivo de describir e interpretar los datos. Si existen muchos elementos, la matriz de similaridades será muy grande y la representación por unas pocas variables de los elementos nos permitirá entender su estructura: qué elementos tienen propiedades similares, si aparecen grupos entre los elementos, si hay elementos atípicos, etc.</p>
<p>El escalado multidimensional representa un enfoque complementario a componentes principales en el sentido siguiente.</p>
<ul>
<li><p>Componentes principales considera la matriz <span class="math inline">\(p \times p\)</span> de correlaciones (o covarianzas) entre variables, e investiga su estructura.</p></li>
<li><p>El escalado multidimensional considera la matriz <span class="math inline">\(n \times n\)</span> de correlaciones (o covarianzas) entre individuos, e investiga su estructura. Los métodos existentes se dividen en métricos, cuando la matriz inicial es propiamente de distancias, y no métricos, cuando la matriz es de similaridades. Los métodos métricos, utilizan las diferencias entre similitudes mientras que los no métricos parten de que si <span class="math inline">\(A\)</span> es más similar a <span class="math inline">\(B\)</span> que a <span class="math inline">\(C\)</span>, entonces <span class="math inline">\(A\)</span> esta más cerca de <span class="math inline">\(B\)</span> que de <span class="math inline">\(C\)</span>, pero las diferencias entre las similitudes <span class="math inline">\(AB\)</span> y <span class="math inline">\(AC\)</span> no tienen interpretación.</p></li>
</ul>
<section id="reconstrucción-de-las-variables-a-partir-de-las-distancias-entre-puntos" class="level3" data-number="4.5.1">
<h3 data-number="4.5.1" class="anchored" data-anchor-id="reconstrucción-de-las-variables-a-partir-de-las-distancias-entre-puntos"><span class="header-section-number">4.5.1</span> Reconstrucción de las variables a partir de las distancias entre puntos</h3>
<p>Dado un conjunto <span class="math inline">\(p\)</span> de variables en <span class="math inline">\(n\)</span> individuos representados en la matriz <span class="math inline">\(\mathbf{X}_{n \times p}\)</span>, podemos construir dos tipos de matrices cuadradas y semidefinidas positivas: la matriz de covarianzas muestral <span class="math inline">\(\mathbf{S}\)</span> (definida por <span class="math inline">\(\frac{1}{n}\mathbf{X}^t \mathbf{X}\)</span>), si las variables tienen media cero, y la matriz de productos cruzados <span class="math inline">\(\mathbf{Q} = \mathbf{XX}^t\)</span>.</p>
<p>El <span class="math inline">\(MDS\)</span> puede verse como un análisis de la matriz <span class="math inline">\(\mathbf{Q}\)</span> y esta puede interpretarse como una matriz de similitudes entre las observaciones ya que sus términos, <span class="math inline">\(q_{ij}\)</span>, contienen el producto escalar de las observaciones de dos elementos dados: <span class="math display">\[q_{ij} = \sum_{k=1}^p x_{ik}x_{jk} = \mathbf{x}_i^t \mathbf{x}_j \;\; \;\;  \; (1)\]</span> En efecto, como <span class="math inline">\(q_{ij}=|\mathbf{x}_i||\mathbf{x}_j|\cos \theta_{ij}\)</span>, si los dos elementos tienen coordenadas similares, <span class="math inline">\(\cos \theta_{ij}\approx 1\)</span> y <span class="math inline">\(q_{ij}\)</span> será grande. Por el contrario, si los dos elementos tienen valores distintos <span class="math inline">\(\cos \theta_{ij}\approx 0\)</span> y <span class="math inline">\(q_{ij}\)</span> será pequeño.</p>
<p>La distancia euclideana al cuadrado entre dos elementos se define por:</p>
<p><span class="math display">\[d^2_{ij}=\sum_{k=1}^p (x_{ik}-x_{jk})^2=\sum_{k}x_{ik}^2+\sum_{k}x_{jk}^2-2\sum_{k}x_{ik}x_{jk}\]</span> y la podemos escribir en función de los términos de la matriz <span class="math inline">\(\mathbf{Q}\)</span>,</p>
<p><span class="math display">\[d^2_{ij}=q_{ii}+q_{jj}-2q_{ij} \;\; \;\;  \; (2)\]</span></p>
<p>Por tanto, dada la matriz <span class="math inline">\(\mathbf{X}\)</span> podemos construir la matriz <span class="math inline">\(\mathbf{Q}\)</span> y a partir de esta matriz es fácil obtener la matriz de distancias al cuadrado con ayuda de las expresiones (1) y (2).</p>
<p>El problema que se aborda en MDS es el inverso: dada una matriz de distancias al cuadrado, <span class="math inline">\(\mathbf{D}\)</span>, con elementos <span class="math inline">\(d^2_{ij}\)</span> se trata de reconstruir la matrix <span class="math inline">\(\mathbf{X}\)</span>.</p>
<p>Lo primero que se plantea es obtener la matriz <span class="math inline">\(\mathbf{Q}\)</span> dada la matriz <span class="math inline">\(\mathbf{D}\)</span>. Para ello, observemos, que sin pérdida de generalidad, siempre podemos suponer que las variables <span class="math inline">\(X\)</span> tienen media cero. En efecto, las distancias entre los puntos, <span class="math inline">\(d^2_{ij}\)</span> no varían si expresamos las variables en desviaciones a la media, ya que:</p>
<p><span class="math display">\[d^2_{ij}=\sum_{k=1}^p (x_{ik}-x_{jk})^2=\sum_{k}\left[ (x_{ik}-\bar{x}_k)-(x_{jk}-\bar{x}_k) \right]^2 \;\; \;\;  \; (3)\]</span> y, por tanto, podemos suponer siempre que las variables que buscamos tienen media cero.</p>
<p>Por ello, como resulta que <span class="math inline">\(\mathbf{X}^t \mathbf{1} = 0\)</span> se debe verificar que <span class="math inline">\(\mathbf{Q}\mathbf{1} = 0\)</span>, es decir, la suma de todos los elementos de una fila de la matriz <span class="math inline">\(\mathbf{Q}\)</span> (y de una columna ya que la matriz es simétrica) debe de ser cero.</p>
<p>Luego, sumamos en (2) por filas: <span class="math display">\[\sum_{i=1}^n d^2_{ij}=\sum_{i=1}^n q_{ii}+nq_{jj}=t+nq_{jj} \;\; \;\;  \; (4)\]</span> donde <span class="math inline">\(t=\sum_{i=1}^n q_{ii}=traza(\mathbf{Q})\)</span>, y sabiendo que <span class="math inline">\(\sum_{i=1}^n q_{ij}=0\)</span>.</p>
<p>Sumando (2) por columnas se tiene: <span class="math display">\[\sum_{j=1}^n d^2_{ij}=n q_{ii}+t \;\; \;\;  \; (5)\]</span> y sumando ahora (4) por filas de nuevo se tiene:</p>
<p><span class="math display">\[\sum_{i=1}^n \sum_{j=1}^n d^2_{ij}=2nt\]</span></p>
<p>Sustituyendo (4) y (5) en (2), tenemos que</p>
<p><span class="math display">\[d^2_{ij}=\frac{1}{n}\sum_{j=1}^n d^2_{ij} - \frac{t}{n} + \frac{1}{n}\sum_{i=1}^n d^2_{ij} - \frac{t}{n} -2 q_{ij},  \]</span> y llamando <span class="math inline">\(d^2_{i.}\)</span> y <span class="math inline">\(d^2_{.j}\)</span> a las medias por filas y por columnas y utilizando (5), tenemos que</p>
<p><span class="math display">\[ d^2_{ij}= d^2_{i.}+ d^2_{.j}-d^2_{..}-2 q_{ij} \;\; \;\;  \; (6) \]</span> donde <span class="math inline">\(d^2_{..}=\frac{1}{n^2}\sum_{i=1}^n \sum_{j=1}^n d^2_{ij}\)</span></p>
<p>Finalmente, despejando de (6) resulta que <span class="math display">\[q_{ij}=-\frac{1}{2}\left( d^2_{ij}-d^2_{i.}-d^2_{.j}+d^2_{..}\right)\]</span> expresión que indica cómo construir la matriz <span class="math inline">\(\mathbf{Q}\)</span> a partir de la matriz de distancias <span class="math inline">\(\mathbf{D}\)</span>.</p>
</section>
<section id="coordenadas-principales-a-partir-de-distancias" class="level3" data-number="4.5.2">
<h3 data-number="4.5.2" class="anchored" data-anchor-id="coordenadas-principales-a-partir-de-distancias"><span class="header-section-number">4.5.2</span> Coordenadas principales a partir de distancias</h3>
<p>Sea <span class="math inline">\(\mathbf{D}\)</span> una matriz de distancias euclídeas al cuadrado entre <span class="math inline">\(n\)</span> objetos. Las <strong>coordenadas principales</strong> son las coordenadas de dichos objetos en <span class="math inline">\(r &lt; n\)</span> dimensiones, <span class="math inline">\(Z_1 \ldots Z_r\)</span> (columnas de una matriz <span class="math inline">\(Z_{n \times r}\)</span>), de manera que la matriz de distancias euclídeas al cuadrado entre las coordenadas de dichos objetos coincida con <span class="math inline">\(\mathbf{D}\)</span>.</p>
<p>Partimos de una matriz de distancias <span class="math inline">\(\mathbf{D}\)</span> obtenida de una matriz de coordenadas <span class="math inline">\(Y\)</span> . Vamos a ver que a partir de <span class="math inline">\(D\)</span> se puede obtener la matriz de productos escalares <span class="math inline">\(Q = Y Y^t\)</span>, y a partir de <span class="math inline">\(Q\)</span> se obtiene otra matriz de coordenadas <span class="math inline">\(Z\)</span>, cuya matriz de distancias coincide con <span class="math inline">\(D\)</span>.</p>
<p>Vamos a suponer que las columnas de <span class="math inline">\(Z\)</span> están centradas.</p>
<p>Si realizamos la descomposición espectral de <span class="math inline">\(\mathbf{Q}\)</span>, <span class="math display">\[\mathbf{Q}=\mathbf{V} \mathbf{\Lambda}\mathbf{V}^t=\left(\mathbf{V} \mathbf{\Lambda}^{1/2} \right) \left( \mathbf{\Lambda}^{1/2} \mathbf{V}^t \right)\]</span> donde <span class="math inline">\(\mathbf{\Lambda}\)</span> es una matriz diagonal con los valores propios no nulos de <span class="math inline">\(\mathbf{Q}\)</span> y <span class="math inline">\(\mathbf{V}\)</span> es una matriz <span class="math inline">\(n \times r\)</span> con los <span class="math inline">\(r\)</span> vectores propios asociados a los valores propios de <span class="math inline">\(Q\)</span> en sus columnas. La matriz de coordenadas principales es: <span class="math display">\[Z= \mathbf{V} \mathbf{\Lambda}^{1/2}\]</span></p>
<p>El procedimiento para obtener las coordenadas principales es el siguiente:</p>
<p>1.- Formar la matriz de distancias al cuadrado, <span class="math inline">\(\mathbf{D}\)</span>, cuyos elementos son los cuadrados de las distancias.</p>
<p>2.- Construir la matriz <span class="math inline">\(\mathbf{Q}\)</span> de productos cruzados.</p>
<p>3.- Obtener los valores y vectores propios de <span class="math inline">\(\mathbf{Q}\)</span>. Tomar los <span class="math inline">\(r\)</span> mayores si podemos suponer que los restantes <span class="math inline">\(n-r\)</span> son próximos a cero.</p>
<p>4.- Obtener las coordenadas de los puntos en las variables mediante <span class="math inline">\(\sqrt{{\lambda_i}} \mathbf{v}_i\)</span>, donde <span class="math inline">\(\mathbf{\lambda}_i\)</span> es el valor propio y <span class="math inline">\(\mathbf{v}_i\)</span> el vector propio.</p>
<p>El método puede aplicarse también cuando la matriz de partida <span class="math inline">\(\mathbf{Q}\)</span> es una matriz de similaridades cualquiera. Entonces <span class="math inline">\(q_{ii}=1\)</span>, <span class="math inline">\(q_{ij}=q_{ji}\)</span> y <span class="math inline">\(0 \leq q_{ij} \leq 1\)</span>. De acuerdo a (2), la matriz de distancias asociadas será: <span class="math display">\[d^2_{ij}= q_{ii}+ q_{jj}-2 q_{ij}=2(1-q_{ij})\]</span> y puede comprobarse que <span class="math inline">\(\sqrt{2(1-q_{ij})}\)</span> es una distancia y verifica la desigualdad triangular al corresponder a la distancia euclideana para cierta configuración de puntos.</p>
</section>
</section>
<section id="selección-del-número-de-dimensiones" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="selección-del-número-de-dimensiones"><span class="header-section-number">4.6</span> Selección del número de dimensiones</h2>
<p>Se ha propuesto como medida de la precisión en la aproximación mediante los <span class="math inline">\(r\)</span> valores propios positivos, los coeficientes:</p>
<p><span class="math display">\[m_{1,r}=\frac{\sum_{i=1}^r |\lambda_i|}{\sum_{i=1}^p |\lambda_i|} \cdot 100\]</span> ó</p>
<p><span class="math display">\[m_{2,r}=\frac{\sum_{i=1}^r \lambda_i^2}{\sum_{i=1}^p \lambda_i^2} \cdot 100\]</span></p>
<section id="ejemplo-a-mano" class="level3" data-number="4.6.1">
<h3 data-number="4.6.1" class="anchored" data-anchor-id="ejemplo-a-mano"><span class="header-section-number">4.6.1</span> Ejemplo a mano</h3>
<p>Sobre el siguiente conjunto de animales <span class="math inline">\(\varepsilon=\{león, jirafa, vaca, oveja, gato, hombre \}\)</span> se han medido las siguientes variables binarias:</p>
<ul>
<li><p><span class="math inline">\(X_1\)</span>: ¿tiene cola?</p></li>
<li><p><span class="math inline">\(X_2\)</span>: ¿es salvaje?</p></li>
<li><p><span class="math inline">\(X_3\)</span>: ¿tiene el cuello largo?</p></li>
<li><p><span class="math inline">\(X_4\)</span>: ¿es animal de granja?</p></li>
<li><p><span class="math inline">\(X_5\)</span>: ¿es carnívoro?</p></li>
<li><p><span class="math inline">\(X_6\)</span>: ¿camina sobre cuatro patas?</p></li>
</ul>
<p>La matriz de datos es :</p>
<p><span class="math display">\[\mathbf{X}=\begin{pmatrix}
1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\
1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\
\end{pmatrix} \begin{matrix}
león\\
jirafa \\
vaca \\
oveja \\
gato \\
hombre
\end{matrix}\]</span></p>
<p>A partir de esta matriz, construimos las coordenadas principales y realizamos una representación en 2 dimensiones. Calcularemos una medida de precisión de la representación que hemos realizado.</p>
<p>En este caso tenemos <span class="math inline">\(\mathbf{X}\)</span>, si no fuese el caso habría que usar una medida de similiaridad como por ejemplo la de Sokal y Mikener (<strong>Ejercicio</strong>)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>X<span class="ot">=</span><span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>           <span class="dv">0</span>, <span class="dv">1</span>,<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>           <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>,<span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>           <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), <span class="at">nrow=</span><span class="dv">6</span>, <span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>X</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    1    0    0    1    1
[2,]    1    1    1    0    0    1
[3,]    1    0    0    1    0    1
[4,]    1    0    0    1    0    1
[5,]    1    0    0    0    1    1
[6,]    0    0    0    0    1    0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>Q<span class="ot">=</span>X <span class="sc">%*%</span> <span class="fu">t</span>(X)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>valores<span class="ot">=</span><span class="fu">eigen</span>(Q)<span class="sc">$</span>values</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>vectores<span class="ot">=</span><span class="fu">eigen</span>(Q)<span class="sc">$</span>vectors</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>y1<span class="ot">=</span><span class="fu">sqrt</span>(valores[<span class="dv">1</span>])<span class="sc">*</span>vectores[,<span class="dv">1</span>]</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>y2<span class="ot">=</span><span class="fu">sqrt</span>(valores[<span class="dv">2</span>])<span class="sc">*</span>vectores[,<span class="dv">2</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Calculamos una medida de precisión (variabilidad explicada) con 2 componentes y miramos la representación</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">m_12=</span>(<span class="fu">sum</span>(<span class="fu">abs</span>(valores[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>]))<span class="sc">/</span><span class="fu">sum</span>(<span class="fu">abs</span>(valores)))<span class="sc">*</span><span class="dv">100</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 86.20502</code></pre>
</div>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">m_22=</span>(<span class="fu">sum</span>(valores[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>]<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span><span class="fu">sum</span>(valores<span class="sc">^</span><span class="dv">2</span>))<span class="sc">*</span><span class="dv">100</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 97.63187</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-27-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="mds-no-métrico" class="level2" data-number="4.7">
<h2 data-number="4.7" class="anchored" data-anchor-id="mds-no-métrico"><span class="header-section-number">4.7</span> MDS no métrico</h2>
<p>Partiendo de la matriz de disimilaridades <span class="math inline">\(\mathbf{\Lambda}=(\delta_{ij})\)</span>, el escalado no métrico consiste en encontrar unas coordenadas, cuyas distancias euclídeas al cuadrado mantengan el órden de las disimilaridades. Es decir, <strong>el escalado no métrico solo tiene en cuenta la información referente al órden entre las disimilaridades, y no su magnitud</strong>. El procedimiento es el siguiente:</p>
<ol type="1">
<li><p>Se calculan unas coordenadas iniciales <span class="math inline">\(Z^{(0)}\)</span>, por ejemplo aplicando MDS métrico a <span class="math inline">\(\mathbf{\Lambda}\)</span>. Esto es, calcular <span class="math inline">\(\mathbf{Q}\)</span>, realizar la descomposición <span class="math inline">\(\mathbf{Q}=\mathbf{V} \mathbf{\Lambda}\mathbf{V}^t\)</span> y tomar <span class="math inline">\(Z^{(0)} =\mathbf{V}_r \mathbf{\Lambda}_r^{1/2}\)</span>, donde <span class="math inline">\(\mathbf{\Lambda}_r\)</span> contiene los <span class="math inline">\(r\)</span> valores propios mayores y sus <span class="math inline">\(\mathbf{V}_r\)</span> vectores propios asociados en columnas. Así, obtenemos <span class="math inline">\(D^{(0)}=(d^{(0)}_{ij})\)</span> a partir de las coordenadas <span class="math inline">\(Z^{(0)}\)</span>.</p></li>
<li><p>Se calculan disparidades <span class="math inline">\(\hat{d}_{ij}\)</span> que son una transformación de las distancias <span class="math inline">\(d_{ij}\)</span> que mantienen la misma ordenación que las disimilaridades <span class="math inline">\(\delta_{ij}\)</span>, es decir <span class="math display">\[\hat{d}_{ij}=f(d_{ij})\]</span> donde <span class="math inline">\(f\)</span> es una función monótona que verifica: Si <span class="math inline">\(\delta_{ij} \leq \delta_{kl}\)</span>, entonces <span class="math inline">\(\hat{d}_{ij} \leq \hat{d}_{kl}\)</span>.</p></li>
</ol>
<p><span style="color: blue;"><em>Ejemplo</em></span>: Consideremos la matriz de disimilaridades <span class="math display">\[\mathbf{\Lambda}=(\delta_{ij})=\begin{pmatrix}
0 &amp; 2.1 &amp; 3 &amp; 2.4\\
  &amp; 0  &amp;  1.7 &amp; 3.9 \\
  &amp;    &amp;  0  &amp; 3.2 \\
  &amp;    &amp;     &amp; 0
\end{pmatrix} \]</span></p>
<p>Supongamos que hemos obtenido una matriz de coordenadas inicial <span class="math inline">\(Z^{(0)},\)</span> cuya matriz de distancias es <span class="math display">\[D^{(0)}=(d^{(0)}_{ij})=\begin{pmatrix}
0 &amp; 1.6 &amp; 4.5 &amp; 5.7\\
  &amp; 0  &amp;  3.3 &amp; 4.3 \\
  &amp;    &amp;  0  &amp; 1.3 \\
  &amp;    &amp;     &amp; 0
\end{pmatrix}\]</span></p>
<p>Obtener las disparidades:</p>
<p>Escribimos las disimilaridades en órden creciente <span class="math display">\[\delta_{23}=1.7, \delta_{12}=2.1, \delta_{14}=2.4, \delta_{13}=3, \delta_{34}=3.2, \delta_{24}=3.9\]</span></p>
<p>Ahora escribimos las distancias correspondientes <span class="math display">\[d_{23}= \ldots, d_{12}= \ldots, d_{14}= \ldots, d_{13}= \ldots, d_{34}= \ldots, d_{24}= \ldots\]</span></p>
<p>Si mantuviesen el mismo órden que las disimilaridades, estarían ordenadas de menor a mayor, y en ese caso, las disparidades serían iguales a las distancias. Entonces <span class="math inline">\(Z^{(0)}\)</span> sería una solución válida.</p>
<p>Una transformación monótona de estas distancias que preserva el órden de las disimilaridades se calcula de la siguiente forma: cuando existe una secuencia de distancias que están ordenadas al contrario de lo deseado, se reemplazan todas estas distancias por la media de las distancias de dicha secuencia. Así, las disparidades son:</p>
<p><span class="math display">\[\begin{align*}
\hat{d}_{23} &amp;= \hat{d}_{12}=\frac{1}{2} (d_{23}+d_{12}), \\
\hat{d}_{14} &amp;= \hat{d}_{13}=\hat{d}_{34}=\frac{1}{3} (d_{14}+d_{13}+d_{34}), \\
\hat{d}_{24} &amp;= d_{24}
\end{align*}\]</span></p>
</section>
<section id="medidas-de-bondad-de-ajuste-de-la-solución-obtenida" class="level2" data-number="4.8">
<h2 data-number="4.8" class="anchored" data-anchor-id="medidas-de-bondad-de-ajuste-de-la-solución-obtenida"><span class="header-section-number">4.8</span> Medidas de bondad de ajuste de la solución obtenida</h2>
<p>Para medir la bondad de ajuste de la solución obtenida:</p>
<ul>
<li><p><strong>STRESS</strong>: <span class="math inline">\(S= \left[\frac{\sum_{i&lt;j} (d_{ij}-\hat{d}_{ij})^2}{\sum_{i&lt;j}d^2_{ij}} \right]^{1/2}\)</span></p>
<ul>
<li><span class="math inline">\(S \in (0, 0.01] \implies\)</span> Solución muy buena;</li>
<li><span class="math inline">\(S \in (0.01, 0.05] \implies\)</span> Solución buena;</li>
<li><span class="math inline">\(S \in (0.05, 0.1] \implies\)</span> Solución aceptable.</li>
</ul></li>
<li><p><strong>S-STRESS</strong>: <span class="math inline">\(S= \left[\frac{\sum_{i&lt;j} (d_{ij}-\hat{d}_{ij})^2}{\sum_{i&lt;j}d^4_{ij}} \right]^{1/2}\)</span></p></li>
</ul>
<p>Esta medida está entre 0 y 1, siendo valores cercanos a cero indicadores de un buen ajuste, y valores cercanos a 1 indicadores de un mal ajuste.</p>
<ul>
<li><strong>RSQ</strong>: Es el coeficiente de correlación al cuadrado entre las distancias y las disparidades. El ajuste es aceptable para RSQ <span class="math inline">\(\geq 0.6\)</span>.</li>
</ul>
<p>Si para las coordenadas actuales, estas medidas no son satisfactorias, entonces pasamos a la búsqueda de una nueva solución. Esta solución se busca minimizando una de las medidas de ajuste respecto a las coordenadas, generalmente se utiliza el STRESS o el S-STRESS.</p>
<p><strong>Minimización del STRESS</strong></p>
<p>Sea <span class="math inline">\(\mathbf{z}=(\mathbf{z}^t_1, \ldots, \mathbf{z}^t_n)\)</span> el vector formado por las <span class="math inline">\(n\)</span> filas de <span class="math inline">\(\mathbf(Z)\)</span> (nuestras incógnitas). El problema es encontrar <span class="math inline">\(\mathbf{z}\)</span> que minimice <span class="math display">\[S= \left[\frac{\sum_{i&lt;j} (d_{ij}(\mathbf{z})-\hat{d}_{ij})^2}{\sum_{i&lt;j}d^2_{ij}(\mathbf{z})} \right]^{1/2}\]</span> donde <span class="math display">\[d^2_{ij}(\mathbf{z})=d^2_e(\mathbf{z}_i,\mathbf{z}_j)=\sum_{k=1}^p (z_{ik}-z_{jk})^2.\]</span> Este problema es no lineal, con lo cual es necesario recurrir a métodos de resolución numéricos.</p>
</section>
<section id="escalamiento-multidimensional-en-r" class="level2" data-number="4.9">
<h2 data-number="4.9" class="anchored" data-anchor-id="escalamiento-multidimensional-en-r"><span class="header-section-number">4.9</span> Escalamiento multidimensional en R</h2>
<p>La función en R para llevar a cabo un MDS es <code>cmdscale(d,k,eig=FALSE)</code>, donde</p>
<ul>
<li><p><code>d</code> es un objeto clase distancia como la producida por <code>dist</code> o una matriz simétrica que contiene disimilaridades.</p></li>
<li><p><code>k</code> es la dimensión del espacio en cual queremos representar los datos.</p></li>
<li><p><code>eig</code> es una variable lógica que indica si los valores propios deben ser presentados.</p></li>
</ul>
<p>Consideremos como ejemplo un conjunto de datos de la librería <code>MVA</code> que contiene las distancias por carretera entre 21 ciudades europeas en km.</p>
<p>En base a estas distancias, deseamos “reconstruir” el mapa.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MVA)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: HSAUR2</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: tools</code></pre>
</div>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"eurodist"</span>)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(eurodist)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> 'dist' num [1:210] 3313 2963 3175 3339 2762 ...
 - attr(*, "Size")= num 21
 - attr(*, "Labels")= chr [1:21] "Athens" "Barcelona" "Brussels" "Calais" ...</code></pre>
</div>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>eur.mds<span class="ot">&lt;-</span><span class="fu">cmdscale</span>(eurodist,<span class="at">k=</span><span class="dv">2</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(eur.mds, <span class="at">type=</span><span class="st">"n"</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(eur.mds, <span class="at">labels =</span> <span class="fu">rownames</span>(eur.mds))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t4_trd_files/figure-html/unnamed-chunk-28-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Hemos obtenido una forma similar a lo que esperaríamos de un mapa de Europa, pero con norte y sur intercambiados.</p>
<p>Un ejemplo de cómo trabajar con tidyverse, ver el siguiente <a href="http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/122-multidimensional-scaling-essentials-algorithms-and-r-code/">link</a></p>
</section>
<section id="práctica" class="level2" data-number="4.10">
<h2 data-number="4.10" class="anchored" data-anchor-id="práctica"><span class="header-section-number">4.10</span> <span style="color: red;"><em>Práctica</em></span></h2>
<p>El metabolismo se caracteriza por reacciones químicas vinculadas entre sí, creando una compleja estructura de red. Una representación simplificada del metabolismo, que denominamos red metabólica abstracta, es un grafo en el que las vías metabólicas son nodos y existe una arista entre dos nodos si sus correspondientes vías comparten uno o más compuestos.</p>
<p>Para explorar los potenciales y límites de una representación tan básica, hemos empleado tres tipos de kernels (distancias entre grafos):</p>
<ul>
<li><p>VH (Vertex histogram): solo tiene en cuenta si las etiquetas de los nodos de los grafos que se comparan son iguales o no.</p></li>
<li><p>SP (Shortest-Path): compara los grafos en función de sus caminos más cortos. Intuitivamente, esto significa medir lo fácil o difícil que es conectar, a través de compuestos compartidos, parejas de caminos en los dos grafos.</p></li>
<li><p>PM (Pyramid Match): mide la similitud de las características topológicas (por ejemplo, la conectividad) de los nodos con la misma etiqueta en los dos grafos comparados.</p></li>
</ul>
<p>La práctica consiste en representar gráficamente (con solo 2 coordenadas principales) las matrices de similitud generadas por cada kernel coloreando los puntos de acuerdo al grupo de animales de acuerdo a su phylum.</p>
<p>Los ficheros necesarios para realizar la práctica los podéis descargar de la página del curso en Aula Digital.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-bakker" class="csl-entry" role="listitem">
Bakker, Jonathan D. 2024. <span>«Applied Multivariate Statistics in R»</span>. 2024. <a href="https://uw.pressbooks.pub/appliedmultivariatestatistics">https://uw.pressbooks.pub/appliedmultivariatestatistics</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/aprender-uib\.github\.io\/AD");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./t3_inferencia.html" class="pagination-link" aria-label="Inferencia multivariante en poblaciones normales">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Inferencia multivariante en poblaciones normales</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./t5_clustering.html" class="pagination-link" aria-label="Agrupamiento (Clustering)">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Agrupamiento (Clustering)</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Análisis de Datos UIB</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/AprendeR-UIB/AD/edit/main/t4_trd.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li><li><a href="https://github.com/AprendeR-UIB/AD/issues/new" class="toc-action"><i class="bi empty"></i>Informar de un problema</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Este libro se ha creado con <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","selector":".lightbox","loop":false,"openEffect":"zoom","descPosition":"bottom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>