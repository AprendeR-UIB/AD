<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Análisis de datos - 5&nbsp; Agrupamiento (Clustering)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./t6_series_temporales.html" rel="next">
<link href="./t4_trd.html" rel="prev">
<link href="./Figuras/atlas.jpeg" rel="icon" type="image/jpeg">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./t5_clustering.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Agrupamiento (Clustering)</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Análisis de datos</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/AprendeR-UIB/AD" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Alternar modo lector">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Presentación</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t1_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción al Análisis de Datos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t2_em.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Análisis Multivariante</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t3_inferencia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Inferencia multivariante en poblaciones normales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t4_trd.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Técnicas de reducción de Dimensionalidad</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t5_clustering.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Agrupamiento (Clustering)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./t6_series_temporales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Series temporales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referencias</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción"><span class="header-section-number">5.1</span> Introducción</a></li>
  <li><a href="#k-medias" id="toc-k-medias" class="nav-link" data-scroll-target="#k-medias"><span class="header-section-number">5.2</span> <span class="math inline">\(k\)</span>-medias</a>
  <ul class="collapse">
  <li><a href="#introducción-1" id="toc-introducción-1" class="nav-link" data-scroll-target="#introducción-1"><span class="header-section-number">5.2.1</span> Introducción</a></li>
  <li><a href="#algoritmo-de-lloyd" id="toc-algoritmo-de-lloyd" class="nav-link" data-scroll-target="#algoritmo-de-lloyd"><span class="header-section-number">5.2.2</span> Algoritmo de Lloyd</a></li>
  <li><a href="#método-del-codo-y-test-f" id="toc-método-del-codo-y-test-f" class="nav-link" data-scroll-target="#método-del-codo-y-test-f"><span class="header-section-number">5.2.3</span> Método del codo y test F</a></li>
  <li><a href="#k-medias-con-r" id="toc-k-medias-con-r" class="nav-link" data-scroll-target="#k-medias-con-r"><span class="header-section-number">5.2.4</span> <span class="math inline">\(k\)</span>-medias con <code>R</code></a></li>
  <li><a href="#ejemplo" id="toc-ejemplo" class="nav-link" data-scroll-target="#ejemplo"><span class="header-section-number">5.2.5</span> Ejemplo</a></li>
  </ul></li>
  <li><a href="#k-medoides" id="toc-k-medoides" class="nav-link" data-scroll-target="#k-medoides"><span class="header-section-number">5.3</span> <span class="math inline">\(k\)</span>-medoides</a>
  <ul class="collapse">
  <li><a href="#introducción-2" id="toc-introducción-2" class="nav-link" data-scroll-target="#introducción-2"><span class="header-section-number">5.3.1</span> Introducción</a></li>
  <li><a href="#ventajas-y-desventajas" id="toc-ventajas-y-desventajas" class="nav-link" data-scroll-target="#ventajas-y-desventajas"><span class="header-section-number">5.3.2</span> Ventajas y desventajas</a></li>
  <li><a href="#ejemplo-1" id="toc-ejemplo-1" class="nav-link" data-scroll-target="#ejemplo-1"><span class="header-section-number">5.3.3</span> Ejemplo</a></li>
  <li><a href="#clara" id="toc-clara" class="nav-link" data-scroll-target="#clara"><span class="header-section-number">5.3.4</span> Clara</a></li>
  </ul></li>
  <li><a href="#jerarquico" id="toc-jerarquico" class="nav-link" data-scroll-target="#jerarquico"><span class="header-section-number">5.4</span> Jerarquico</a>
  <ul class="collapse">
  <li><a href="#introducción-3" id="toc-introducción-3" class="nav-link" data-scroll-target="#introducción-3"><span class="header-section-number">5.4.1</span> Introducción</a></li>
  <li><a href="#ejemplo-2" id="toc-ejemplo-2" class="nav-link" data-scroll-target="#ejemplo-2"><span class="header-section-number">5.4.2</span> Ejemplo</a></li>
  <li><a href="#jerarquico-aglomerativo" id="toc-jerarquico-aglomerativo" class="nav-link" data-scroll-target="#jerarquico-aglomerativo"><span class="header-section-number">5.4.3</span> Jerarquico aglomerativo</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/AprendeR-UIB/AD/edit/main/t5_clustering.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li><li><a href="https://github.com/AprendeR-UIB/AD/issues/new" class="toc-action"><i class="bi empty"></i>Informar de un problema</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Agrupamiento (Clustering)</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introducción" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="introducción"><span class="header-section-number">5.1</span> Introducción</h2>
<p>El término <code>clustering</code> se refiere a una amplia gama de técnicas no supervisadas que buscan identificar patrones o grupos (clusters) dentro de un conjunto de las observaciones. Estas particiones se establecen de manera que las observaciones dentro de un mismo grupo sean similares entre sí y diferentes de las observaciones en otros grupos.</p>
<p>Dado el amplio espectro de aplicaciones del clustering en diversos campos, como la genómica y el marketing, se han desarrollado numerosas variantes y adaptaciones de sus métodos y algoritmos. Estas variantes pueden agruparse en las siguientes categorías principales:</p>
<ul>
<li><p>Clustering de Particionamiento: Algoritmos que requieren la especificación previa del número de clusters: K-means, K-medoids, y CLARA.</p></li>
<li><p>Clustering Jerárquico: Algoritmos que no requieren especificar el número de clusters: aglomerativos y divisivos.</p></li>
</ul>
<p>Aunque existen métodos que combinan ambos tipos de clustering, en la asignatura se incluye únicamente los listados anteriormente porque se hace énfasis en la comprensión del algoritmo que se está utilizando y en la interpretación de los resultados en el contexto del problema.</p>
<p>Dado un conjunto de objetos, queremos clasificarlos en grupos (<strong>clusters</strong>) basándonos en sus semejanzas y diferencias.</p>
<p>Algunas aplicaciones en biología:</p>
<ul>
<li><p>Clasificación jerárquica de organismos (relacionada con la filogenia).</p></li>
<li><p>Agrupamiento de genes con patrones de expresión similares.</p></li>
<li><p>Agrupamiento de genes por similitud secuencial.</p></li>
<li><p>Agrupamiento de proteínas por similitud estructural.</p></li>
</ul>
<p><strong>Principios básicos</strong></p>
<ul>
<li><p><span style="color: blue;"><em>Homogeneidad</em></span>: Objetos dentro de un mismo clúster han de ser semejantes (próximos).</p></li>
<li><p><span style="color: blue;"><em>Separación</em></span>: Objetos dentro de clústers diferentes han de ser lejanos.</p></li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="t5_clustering_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>¿Cómo formalizamos estos principios intuitivos?</p>
<p>Principalmente hay dos tipos diferentes de clustering :</p>
<ul>
<li><span style="color: blue;"><em>De partición</em></span>: Dividimos los objetos en un número prefijado de clusters; posiblemente probamos diversos número de grupos y nos quedamos con el mejor agrupamiento.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Figuras/particion.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<ul>
<li><span style="color: blue;"><em>Jerárquico</em></span>: Agrupamos sucesivamente <strong>aglomerativo</strong> o dividimos <strong>divisivo</strong> los objetos o grupos de objetos. Producimos un árbol de clasificación.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Figuras/jerarquico.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
<section id="k-medias" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="k-medias"><span class="header-section-number">5.2</span> <span class="math inline">\(k\)</span>-medias</h2>
<section id="introducción-1" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="introducción-1"><span class="header-section-number">5.2.1</span> Introducción</h3>
<p>El algoritmo de las <span class="math inline">\(k\)</span>-medias (<span class="math inline">\(k\)</span>-means) busca una partición del conjunto de objetos, representados como elementos de un espacio <span class="math inline">\(\mathbb{R}^n\)</span> en un número fijo <span class="math inline">\(k\)</span> de clusters.</p>
<p>Estos clusters se identifican por medio de sus puntos medios (<strong>means</strong>).</p>
<p>Recordad que dado <span class="math inline">\(\mathbf{x}=(x_1,\ldots,x_n)\in \mathbb{R}^n\)</span>, <span class="math display">\[
\|\mathbf{x}\|^2=\sum_{i=1}^n x_i^2\in \mathbb{R}
\]</span> y que dados <span class="math inline">\(\mathbf{x},\mathbf{y} \in \mathbb{R}^n\)</span>, <span class="math inline">\(\|\mathbf{x}-\mathbf{y}\|\)</span> es la <strong>distancia euclidiana</strong> entre <span class="math inline">\(\mathbf{x}\)</span> y <span class="math inline">\(\mathbf{y}\)</span>.</p>
<p>Fijamos el número de clusters <span class="math inline">\(k\)</span></p>
<p>Dados puntos <span class="math inline">\(\mathbf{x}_1,\ldots,\mathbf{x}_p\in \mathbb{R}^n\)</span>, el objetivo es encontrar <span class="math inline">\(k\)</span> puntos <span class="math inline">\(\mathbf{c}_1,\ldots,\mathbf{c}_k\in \mathbb{R}^n\)</span> que minimicen <span class="math display">\[
SS_C(\mathbf{x}_1,\ldots,\mathbf{x}_p; k)=\sum_{i=1}^p\min_{j=1,\ldots,k} \|\mathbf{x}_i-\mathbf{c}_j\|^2
\]</span> Entonces cada <span class="math inline">\(\mathbf{c}_j\)</span> definirá el clúster formado por los <span class="math inline">\(\mathbf{x}_i\)</span> que están más cerca más cerca de él que de cualquier otro <span class="math inline">\(\mathbf{c}_l\)</span>: <span class="math display">\[
C_j=\{\mathbf{x}_i\mid \|\mathbf{x}_i-\mathbf{c}_j\|&lt;\|\mathbf{x}_i-\mathbf{c}_l\|\mbox{ para todo }l\neq j\}
\]</span> y <span class="math display">\[
SS_C(\mathbf{x}_1,\ldots,\mathbf{x}_p; k)=\sum_{j=1}^k\sum_{\mathbf{x}_i\in C_j}  \|\mathbf{x}_i-\mathbf{c}_j\|^2
\]</span></p>
</section>
<section id="algoritmo-de-lloyd" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="algoritmo-de-lloyd"><span class="header-section-number">5.2.2</span> Algoritmo de Lloyd</h3>
<ul>
<li>Escogemos <span class="math inline">\(\mathbf{c}_1,\ldots,\mathbf{c}_k\)</span> (como queramos).</li>
<li>Asignamos cada punto <span class="math inline">\(\mathbf{x}_i\)</span> al cluster <span class="math inline">\(C_j\)</span> definido por el centro <span class="math inline">\(\mathbf{c}_j\)</span> más cercano.</li>
<li>Substituimos cada centro <span class="math inline">\(\mathbf{c}_j\)</span> por el punto medio de su cluster <span class="math inline">\(C_j\)</span>: <span class="math display">\[\mathbf{c}_j= \Big(\sum_{\mathbf{x}_i\in C_j} \mathbf{x}_i\Big)/|C_j|\]</span></li>
<li>Repetimos los pasos anteriores hasta que los clústers se estabilicen, o un número prefijado de iteraciones.</li>
</ul>
<p>El resultado depende de los <span class="math inline">\(\mathbf{c}_1,\ldots,\mathbf{c}_k\)</span> iniciales.</p>
<p>Este algoritmo no tiene porque dar un clustering óptimo. Conviene repetirlo varias veces con diferentes valores iniciales.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[25,25,25,25], [25,25,25,25]]">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<p><a href="Figuras/kmeans0.png" class="lightbox" data-gallery="ejemplo-kmeans"><img src="Figuras/kmeans0.png" class="img-fluid"></a></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<p><a href="Figuras/kmeans1.png" class="lightbox" data-gallery="ejemplo-kmeans"><img src="Figuras/kmeans1.png" class="img-fluid"></a></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<p><a href="Figuras/kmeans2.png" class="lightbox" data-gallery="ejemplo-kmeans"><img src="Figuras/kmeans2.png" class="img-fluid"></a></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<p><a href="Figuras/kmeans3.png" class="lightbox" data-gallery="ejemplo-kmeans"><img src="Figuras/kmeans3.png" class="img-fluid"></a></p>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<p><a href="Figuras/kmeans4.png" class="lightbox" data-gallery="ejemplo-kmeans"><img src="Figuras/kmeans4.png" class="img-fluid"></a></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<p><a href="Figuras/kmeans5.png" class="lightbox" data-gallery="ejemplo-kmeans"><img src="Figuras/kmeans5.png" class="img-fluid"></a></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<p><a href="Figuras/kmeans6.png" class="lightbox" data-gallery="ejemplo-kmeans"><img src="Figuras/kmeans6.png" class="img-fluid"></a></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<p><a href="Figuras/kmeans7.png" class="lightbox" data-gallery="ejemplo-kmeans"><img src="Figuras/kmeans7.png" class="img-fluid"></a></p>
</div>
</div>
</div>
<p>Limitaciones de <span class="math inline">\(k\)</span>-means:</p>
<ul>
<li>No hay un método eficiente y universal para escoger los centros de partida</li>
<li>No se puede garantizar un óptimo global</li>
<li>No se puede determinar de manera efectiva el número <span class="math inline">\(k\)</span> <em>a priori</em></li>
<li>No es invariante por cambios de escala (conviene estandardizar datos)</li>
<li>Sensible a <em>outliers</em></li>
<li>Solo aplicable dentro <span class="math inline">\(\mathbb{R}^n\)</span> con distancia euclidiana</li>
<li>Encuentra clusters esféricos</li>
</ul>
</section>
<section id="método-del-codo-y-test-f" class="level3" data-number="5.2.3">
<h3 data-number="5.2.3" class="anchored" data-anchor-id="método-del-codo-y-test-f"><span class="header-section-number">5.2.3</span> Método del codo y test F</h3>
<p>El <span class="math inline">\(SS_C\)</span> óptimo disminuye con <span class="math inline">\(k\)</span> siguiendo una función más o menos cóncava. Si podemos detectar un <span class="math inline">\(k\)</span> a partir del cual <span class="math inline">\(SS_C\)</span> disminuya mucho más lentamente que su anterior, este será el <span class="math inline">\(k\)</span> recomendable.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t5_clustering_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><span class="math inline">\(k=3\)</span> es el más recomendable</p>
<p>Se calcula</p>
<p><span class="math display">\[F_k=\frac{SS_C(k)-SS_C(k+1)}{\frac{SS_C(k+1)}{p-k-1}}\]</span> Se escoge como p-valor <span class="math display">\[P(F_{n,n(p-k-1)}&gt;F_k)\]</span> con <span class="math inline">\(F_{n,n(p-k-1)}\)</span> una F de Fisher con <span class="math inline">\(n\)</span> y <span class="math inline">\(n(p-k-1)\)</span> grados de libertad, y escogemos el <span class="math inline">\(k\)</span> con p-valor más pequeño Cabe decir que es un método muy utilizado, pero no demasiado justificable.</p>
<p>En el ejemplo del gráfico anterior</p>
<table class="table">
<thead>
<tr class="header">
<th><span class="math inline">\(k\)</span></th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(SS_C(k)\)</span></td>
<td>8.264</td>
<td>5.344</td>
<td>3.254</td>
<td>2.428</td>
<td>1.925</td>
<td>1.677</td>
<td>1.27</td>
</tr>
<tr class="even">
<td><span class="math inline">\(F_k\)</span></td>
<td>8.2</td>
<td>9</td>
<td>4.42</td>
<td>3.14</td>
<td>1.63</td>
<td>3.2</td>
<td></td>
</tr>
<tr class="odd">
<td>p-valor</td>
<td>0.0014</td>
<td>0.001</td>
<td>0.02</td>
<td>0.06</td>
<td>0.229</td>
<td>0.06</td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(k=3\)</span> vuelve a ser el más recomendable</p>
<p>Si el conjunto de puntos es muy grande, todos los <span class="math inline">\(p\)</span>-valores son cercanos a 0 y este método no es útil.</p>
</section>
<section id="k-medias-con-r" class="level3" data-number="5.2.4">
<h3 data-number="5.2.4" class="anchored" data-anchor-id="k-medias-con-r"><span class="header-section-number">5.2.4</span> <span class="math inline">\(k\)</span>-medias con <code>R</code></h3>
<p>La instrucción básica para ejecutar un <span class="math inline">\(k\)</span>-means amb <code>R</code> es</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">kmeans</span>(x,centres,<span class="at">iter.max=</span>...)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>con:</p>
<ul>
<li><code>x</code>, una matriz con los puntos <span class="math inline">\(\mathbf{x}_i\)</span> como filas</li>
<li><code>centres</code>, una matriz con los centros <span class="math inline">\(\mathbf{c}_i\)</span> de partida como filas, o el número <span class="math inline">\(k\)</span></li>
<li><code>iter.max</code>, el número máximo de iteraciones</li>
</ul>
<p>Esta instrucción no sigue exactamente nuestro algoritmo, si queréis que ejecute el algoritmo explicado tenéis que poner, además, <code>algorithm="Lloyd"</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dades<span class="ot">=</span><span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.8</span>,<span class="fl">1.3</span>,<span class="fl">0.8</span>,<span class="fl">1.8</span>,<span class="fl">1.0</span>,<span class="fl">0.9</span>,<span class="fl">1.1</span>,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fl">0.1</span>,<span class="fl">1.1</span>,<span class="fl">1.6</span>,<span class="fl">1.4</span>,<span class="fl">0.6</span>,<span class="fl">1.5</span>,<span class="fl">0.1</span>,<span class="dv">2</span>,<span class="fl">2.1</span>,<span class="fl">1.5</span>,<span class="fl">2.3</span>,<span class="fl">1.8</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fl">1.8</span>,<span class="fl">2.3</span>,<span class="fl">0.5</span>,<span class="fl">0.3</span>,<span class="fl">2.2</span>,<span class="dv">1</span>,<span class="fl">2.5</span>,<span class="dv">2</span>,<span class="fl">0.5</span>,<span class="dv">2</span>,<span class="fl">1.5</span>,<span class="fl">2.5</span>,<span class="dv">1</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fl">0.5</span>,<span class="fl">0.5</span>,<span class="dv">1</span>,<span class="dv">2</span>), </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="at">nrow=</span><span class="dv">18</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>) </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>cent<span class="ot">=</span><span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.5</span>,<span class="dv">0</span>,<span class="fl">0.5</span>,<span class="fl">1.5</span>,<span class="fl">0.5</span>,<span class="dv">3</span>),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="at">nrow=</span><span class="dv">3</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="fu">kmeans</span>(dades,cent,<span class="at">algorithm=</span><span class="st">"Lloyd"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>K-means clustering with 3 clusters of sizes 8, 5, 5

Cluster means:
    [,1]  [,2]
1 1.5375 0.525
2 1.3000 1.600
3 1.1600 2.220

Clustering vector:
 [1] 2 2 1 1 2 1 1 3 3 2 1 3 3 1 2 1 1 3

Within cluster sum of squares by cluster:
[1] 4.03375 1.46000 1.76000
 (between_SS / total_SS =  57.9 %)

Available components:

[1] "cluster"      "centers"      "totss"        "withinss"     "tot.withinss"
[6] "betweenss"    "size"         "iter"         "ifault"      </code></pre>
</div>
</div>
<p>Componentes de la <code>list</code> <code>kmeans</code>:</p>
<ul>
<li><code>cluster</code>: asignaciones de elementos a clusters</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>km<span class="ot">=</span><span class="fu">kmeans</span>(dades,cent,<span class="at">algorithm=</span><span class="st">"Lloyd"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>km<span class="sc">$</span>cluster</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 2 2 1 1 2 1 1 3 3 2 1 3 3 1 2 1 1 3</code></pre>
</div>
</div>
<ul>
<li><code>centers</code>: los centros de los clusters</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>km<span class="sc">$</span>centers</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    [,1]  [,2]
1 1.5375 0.525
2 1.3000 1.600
3 1.1600 2.220</code></pre>
</div>
</div>
<ul>
<li><code>totss</code>: suma de los cuadrados de las distancias de los puntos a su centre</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>km<span class="sc">$</span>totss</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 17.20944</code></pre>
</div>
</div>
<ul>
<li><code>withinss</code>: vector de las sumas, para cada cluster, de los cuadrados de las distancias de sus puntos a su centro</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>km<span class="sc">$</span>withinss</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4.03375 1.46000 1.76000</code></pre>
</div>
</div>
<ul>
<li><code>tot.withinss</code>: suma de <code>withinss</code>, <span class="math inline">\(SS_C\)</span></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>km<span class="sc">$</span>tot.withinss  </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 7.25375</code></pre>
</div>
</div>
<ul>
<li><code>betweenss</code>: diferencia <code>totss - tot.withinss</code></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>km<span class="sc">$</span>betweenss   </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 9.955694</code></pre>
</div>
</div>
<ul>
<li>Nos interesa <code>betweenss/totss</code>, que mide la fracción de la variabilidad de los datos que explican los clusters. Cuanto más grande mejor, y viene dado por <code>kmeans</code></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (between_SS / total_SS =  57.9 %)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fl">9.955694</span><span class="sc">/</span><span class="fl">17.20944</span>  <span class="co">#betweenss/totss</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5785019</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>km.rand<span class="ot">=</span><span class="fu">kmeans</span>(dades,<span class="dv">3</span>,<span class="at">algorithm=</span><span class="st">"Lloyd"</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>km.rand</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>K-means clustering with 3 clusters of sizes 6, 4, 8

Cluster means:
    [,1]      [,2]
1 1.8000 0.4666667
2 1.8250 1.9250000
3 0.8125 1.6000000

Clustering vector:
 [1] 3 3 3 1 3 1 1 2 2 2 1 3 3 1 2 1 3 3

Within cluster sum of squares by cluster:
[1] 2.093333 0.535000 3.708750
 (between_SS / total_SS =  63.2 %)

Available components:

[1] "cluster"      "centers"      "totss"        "withinss"     "tot.withinss"
[6] "betweenss"    "size"         "iter"         "ifault"      </code></pre>
</div>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (between_SS / total_SS =  67.8 %)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>km.rand<span class="sc">$</span>tot.withinss</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6.337083</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>km2<span class="ot">=</span><span class="fu">kmeans</span>(dades,<span class="dv">3</span>)  <span class="co">#5a repetición ;-) </span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>km2</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>K-means clustering with 3 clusters of sizes 7, 7, 4

Cluster means:
       [,1]      [,2]
1 0.9285714 1.9571429
2 1.4000000 0.4571429
3 2.0750000 1.6000000

Clustering vector:
 [1] 1 1 2 2 1 2 2 3 1 3 2 1 1 2 3 3 2 1

Within cluster sum of squares by cluster:
[1] 1.851429 2.717143 0.927500
 (between_SS / total_SS =  68.1 %)

Available components:

[1] "cluster"      "centers"      "totss"        "withinss"     "tot.withinss"
[6] "betweenss"    "size"         "iter"         "ifault"      </code></pre>
</div>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (between_SS / total_SS =  68.9 %)</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>km2<span class="sc">$</span>tot.withinss</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5.496071</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>kmeans1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data=</span>dades, <span class="fu">aes</span>(x, y)) <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">color=</span>km<span class="sc">$</span>cluster) <span class="sc">+</span> <span class="fu">theme_minimal</span>()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>kmeans2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data=</span>dades, <span class="fu">aes</span>(x, y)) <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">color=</span>km2<span class="sc">$</span>cluster) <span class="sc">+</span> <span class="fu">theme_minimal</span>()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Figuras/EjemploKmeans1.png" class="lightbox" data-gallery="kmeans" data-glightbox="description: .lightbox-desc-9" title="El nuestro"><img src="Figuras/EjemploKmeans1.png" class="img-fluid figure-img" alt="El nuestro"></a></p>
<figcaption>El nuestro</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Figuras/EjemploKmeans2.png" class="lightbox" data-gallery="kmeans" data-glightbox="description: .lightbox-desc-10" title="El óptimo"><img src="Figuras/EjemploKmeans2.png" class="img-fluid figure-img" alt="El óptimo"></a></p>
<figcaption>El óptimo</figcaption>
</figure>
</div>
</div>
</div>
</div>
</section>
<section id="ejemplo" class="level3" data-number="5.2.5">
<h3 data-number="5.2.5" class="anchored" data-anchor-id="ejemplo"><span class="header-section-number">5.2.5</span> Ejemplo</h3>
<p>El paquete <code>factoextra</code> creado por Alboukadel Kassambara contiene funciones que facilitan en gran medida la visualización y evaluación de los resultados de <em>clustering</em>.</p>
<p><em>El set de datos <code>USArrests</code> contiene información sobre el número de delitos (asaltos, asesinatos y secuestros) junto con el porcentaje de población urbana para cada uno de los 50 estados de USA. Se pretende estudiar si existe una agrupación subyacente de los estados empleando K-means-clustering</em>.</p>
<p>Si se emplea <em>K-means-clustering</em> con distancia euclídea hay que asegurarse de que las variables empleadas son de tipo continuo, ya que trabaja con la media de cada una de ellas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"USArrests"</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(USArrests)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   50 obs. of  4 variables:
 $ Murder  : num  13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 ...
 $ Assault : int  236 263 294 190 276 204 110 238 335 211 ...
 $ UrbanPop: int  58 48 80 50 91 78 77 72 80 60 ...
 $ Rape    : num  21.2 44.5 31 19.5 40.6 38.7 11.1 15.8 31.9 25.8 ...</code></pre>
</div>
</div>
<p>Como la magnitud de los valores difiere notablemente entre variables, se procede a escalarlas antes de aplicar el <em>clustering</em>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>datos <span class="ot">&lt;-</span> <span class="fu">scale</span>(USArrests)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Una forma sencilla de estimar el número <span class="math inline">\(K\)</span> óptimo de <em>clusters</em> cuando no se dispone de información adicional en la que basarse es aplicar el algoritmo para un rango de valores de <span class="math inline">\(K\)</span>, identificando aquel a partir del cual la reducción en la suma total de varianza <em>intra-cluster</em> deja de ser sustancial (en los siguientes apartados se detallan otras opciones). La función <code>fviz_nbclust()</code> automatiza este proceso.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(factoextra)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_nbclust</span>(<span class="at">x =</span> datos, <span class="at">FUNcluster =</span> kmeans, <span class="at">method =</span> <span class="st">"wss"</span>,</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">diss =</span> <span class="fu">dist</span>(datos, <span class="at">method =</span> <span class="st">"euclidean"</span>)) <span class="sc">+</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="dv">4</span>, <span class="at">linetype =</span> <span class="dv">2</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t5_clustering_files/figure-html/ejemplo1.3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>En este caso, a partir de 4 <em>clusters</em> la reducción en la suma total de cuadrados internos parece estabilizarse, indicando que <span class="math inline">\(K=4\)</span> es una buena opción.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>km_clusters <span class="ot">&lt;-</span> <span class="fu">kmeans</span>(<span class="at">x =</span> datos, <span class="at">centers =</span> <span class="dv">4</span>, <span class="at">nstart =</span> <span class="dv">25</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El paquete <code>factoextra</code> también permite obtener visualizaciones de las agrupaciones resultantes. Si el número de variables (dimensionalidad) es mayor de 2, automáticamente realiza un <em>PCA</em> y representa las dos primeras componentes principales.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_cluster</span>(<span class="at">object =</span> km_clusters, <span class="at">data =</span> datos, <span class="at">show.clust.cent =</span> <span class="cn">TRUE</span>,</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">ellipse.type =</span> <span class="st">"euclid"</span>, <span class="at">star.plot =</span> <span class="cn">TRUE</span>, <span class="at">repel =</span> <span class="cn">TRUE</span>) <span class="sc">+</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t5_clustering_files/figure-html/ejemplo1.5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="k-medoides" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="k-medoides"><span class="header-section-number">5.3</span> <span class="math inline">\(k\)</span>-medoides</h2>
<p>Este capítulo es un extracto del libro <em>Clustering y heatmaps: aprendizaje no supervisado</em> por Joaquín Amat Rodrigo, que está disponible en su <em>GitHub</em>. <span class="citation" data-cites="amat">(véase <a href="referencias.html#ref-amat" role="doc-biblioref">Amat 2017</a>)</span></p>
<section id="introducción-2" class="level3" data-number="5.3.1">
<h3 data-number="5.3.1" class="anchored" data-anchor-id="introducción-2"><span class="header-section-number">5.3.1</span> Introducción</h3>
<p><em>K-medoids</em> es un método de <em>clustering</em> muy similar a <em>K-means</em> en cuanto a que ambos agrupan las observaciones en <span class="math inline">\(K\)</span> <em>clusters</em>, donde <span class="math inline">\(K\)</span> es un valor preestablecido por el analista. La diferencia es que en <em>K-medoids</em> cada <em>cluster</em> está representado por una observación presente en el <em>cluster</em> (<em>medoid</em>), mientras que en <em>K-means</em> cada <em>cluster</em> está representado por su centroide, que se corresponde con el promedio de todas las observaciones del <em>cluster</em> pero con ninguna en particular.</p>
<p>Una definición más exacta del término <em>medoid</em> es: elemento dentro de un <em>cluster</em> cuya distancia (diferencia) promedio entre él y todos los demás elementos del mismo <em>cluster</em> es lo menor posible. Se corresponde con el elemento más central del <em>cluster</em> y por lo tanto puede considerarse como el más representativo. El hecho de utilizar <em>medoids</em> en lugar de centroides hace de <em>K-medoids</em> un método más robusto que <em>K-means</em>, viéndose menos afectado por <em>outliers</em> o ruido. A modo de idea intuitiva puede considerarse como la analogía entre media y mediana.</p>
<p>El algoritmo más empleado para aplicar <em>K-medoids</em> se conoce como <em>PAM</em> (<em>Partitioning Around Medoids</em>) y sigue los siguientes pasos:</p>
<ol type="1">
<li>Seleccionar <span class="math inline">\(K\)</span> observaciones aleatorias como <em>medoids</em> iniciales. También es posible identificarlas de forma específica.</li>
<li>Calcular la matriz de distancia entre todas las observaciones si esta no se ha calculado anteriormente.</li>
<li>Asignar cada observación a su <em>medoid</em> más cercano.</li>
<li>Para cada uno de los clusters creados, comprobar si seleccionando otra observación como <em>medoid</em> se consigue reducir la distancia promedio del <em>cluster</em>, si esto ocurre seleccionar la observación que consigue una mayor reducción como nuevo <em>medoid.</em></li>
<li>Si al menos un <em>medoid</em> ha cambiado en el paso 4, volver al paso 3, de lo contrario se termina el proceso.</li>
</ol>
<p>Por lo general, el método de <em>K-medoids</em> se utiliza cuando se conoce o se sospecha de la presencia de <em>outliers</em>. Si esto ocurre, es recomendable utilizar como medida de similitud la distancia de Manhattan, ya que es menos sensible a <em>outliers</em> que la euclídea.</p>
</section>
<section id="ventajas-y-desventajas" class="level3" data-number="5.3.2">
<h3 data-number="5.3.2" class="anchored" data-anchor-id="ventajas-y-desventajas"><span class="header-section-number">5.3.2</span> Ventajas y desventajas</h3>
<ul>
<li><em>K-medoids</em> es un método de <em>clustering</em> más robusto que <em>K-means</em>, por lo es más adecuado cuando el set de datos contiene <em>outliers</em> o ruido.</li>
<li>Al igual que <em>K-means</em>, necesita que se especifique de antemano el número de <em>clusters</em> que se van a crear. Esto puede ser complicado de determinar si no se dispone de información adicional sobre los datos.</li>
<li>Para sets de datos grandes necesita muchos recursos computacionales. En tal situación se recomienda aplicar el método CLARA.</li>
</ul>
</section>
<section id="ejemplo-1" class="level3" data-number="5.3.3">
<h3 data-number="5.3.3" class="anchored" data-anchor-id="ejemplo-1"><span class="header-section-number">5.3.3</span> Ejemplo</h3>
<p>El proceso a seguir en <code>R</code> para aplicar el método de <em>K-medoids</em> es igual al seguido en <em>K-means</em>, pero en este caso empleando la función <code>pam()</code> del paquete <code>cluster</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"USArrests"</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(USArrests)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   50 obs. of  4 variables:
 $ Murder  : num  13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 ...
 $ Assault : int  236 263 294 190 276 204 110 238 335 211 ...
 $ UrbanPop: int  58 48 80 50 91 78 77 72 80 60 ...
 $ Rape    : num  21.2 44.5 31 19.5 40.6 38.7 11.1 15.8 31.9 25.8 ...</code></pre>
</div>
</div>
<p>Como la magnitud de los valores difiere notablemente entre variables, se procede a escalarlas antes de aplicar el <em>clustering</em>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>datos <span class="ot">&lt;-</span> <span class="fu">scale</span>(USArrests)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Una forma sencilla de estimar el número <span class="math inline">\(K\)</span> óptimo de <em>clusters</em> cuando no se dispone de información adicional en la que basarse es aplicar el algoritmo para un rango de valores de <span class="math inline">\(K\)</span>, identificando aquel a partir del cual la reducción en la suma total de varianza <em>intra-cluster</em> deja de ser sustancial. La función <code>fviz_nbclust()</code> automatiza este proceso. En este caso, dado que se sospecha de la presencia de <em>outliers</em>, se emplea la distancia de Manhattan como medida de similitud.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cluster)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(factoextra)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_nbclust</span>(<span class="at">x =</span> datos, <span class="at">FUNcluster =</span> pam, <span class="at">method =</span> <span class="st">"wss"</span>,</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">diss =</span> <span class="fu">dist</span>(datos, <span class="at">method =</span> <span class="st">"manhattan"</span>))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t5_clustering_files/figure-html/ejemplo2.3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>A partir de 4 <em>clusters</em> la reducción en la suma total de cuadrados internos parece estabilizarse, indicando que <span class="math inline">\(K = 4\)</span> es una buena opción.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>pam_clusters <span class="ot">&lt;-</span> <span class="fu">pam</span>(<span class="at">x =</span> datos, <span class="at">k =</span> <span class="dv">4</span>, <span class="at">metric =</span> <span class="st">"manhattan"</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>pam_clusters</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Medoids:
         ID     Murder    Assault   UrbanPop         Rape
Alabama   1  1.2425641  0.7828393 -0.5209066 -0.003416473
Michigan 22  0.9900104  1.0108275  0.5844655  1.480613993
Oklahoma 36 -0.2727580 -0.2371077  0.1699510 -0.131534211
Iowa     15 -1.2829727 -1.3770485 -0.5899924 -1.060387812
Clustering vector:
       Alabama         Alaska        Arizona       Arkansas     California 
             1              2              2              3              2 
      Colorado    Connecticut       Delaware        Florida        Georgia 
             2              4              3              2              1 
        Hawaii          Idaho       Illinois        Indiana           Iowa 
             3              4              2              3              4 
        Kansas       Kentucky      Louisiana          Maine       Maryland 
             3              3              1              4              2 
 Massachusetts       Michigan      Minnesota    Mississippi       Missouri 
             3              2              4              1              3 
       Montana       Nebraska         Nevada  New Hampshire     New Jersey 
             3              3              2              4              3 
    New Mexico       New York North Carolina   North Dakota           Ohio 
             2              2              1              4              3 
      Oklahoma         Oregon   Pennsylvania   Rhode Island South Carolina 
             3              3              3              3              1 
  South Dakota      Tennessee          Texas           Utah        Vermont 
             4              1              2              3              4 
      Virginia     Washington  West Virginia      Wisconsin        Wyoming 
             3              3              4              4              3 
Objective function:
   build     swap 
1.730682 1.712075 

Available components:
 [1] "medoids"    "id.med"     "clustering" "objective"  "isolation" 
 [6] "clusinfo"   "silinfo"    "diss"       "call"       "data"      </code></pre>
</div>
</div>
<p>El objeto devuelto por <code>pam()</code> contiene entre otra información: las observaciones que finalmente se han seleccionado como <em>medoids</em> y el <em>cluster</em> al que se ha asignado cada observación.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_cluster</span>(<span class="at">object =</span> pam_clusters, <span class="at">data =</span> datos, <span class="at">ellipse.type =</span> <span class="st">"t"</span>, <span class="at">repel =</span> <span class="cn">TRUE</span>) <span class="sc">+</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t5_clustering_files/figure-html/ejemplo2.5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Como en k-medoids no hay centroides, no se muestran en la representación ni</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co"># tampoco las distancias desde este al resto de observaciones</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función <code>fviz_cluster()</code> no permite resaltar las observaciones que actúan como <em>medoids</em>, sin embargo, al tratarse de un objeto <code>ggplot2</code> es sencillo conseguirlo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Como hay más de 2 variables, se están representando las 2 primeras componentes</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co"># de un PCA. Se tienen que calcular el PCA y extraer las proyecciones almacenadas</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co"># en el elemento x</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>medoids <span class="ot">&lt;-</span> <span class="fu">prcomp</span>(datos)<span class="sc">$</span>x</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Se seleccionan únicamente las proyecciones de las observaciones que son medoids</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>medoids <span class="ot">&lt;-</span> medoids[<span class="fu">rownames</span>(pam_clusters<span class="sc">$</span>medoids), <span class="fu">c</span>(<span class="st">"PC1"</span>, <span class="st">"PC2"</span>)]</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>medoids <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(medoids)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Se emplean los mismos nombres que en el objeto ggplot</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(medoids) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Creación del gráfico</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_cluster</span>(<span class="at">object =</span> pam_clusters, <span class="at">data =</span> datos, <span class="at">ellipse.type =</span> <span class="st">"t"</span>, <span class="at">repel =</span> <span class="cn">TRUE</span>) <span class="sc">+</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Se resaltan las observaciones que actúan como medoids</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="fu">geom_point</span>(<span class="at">data =</span> medoids, <span class="at">color =</span> <span class="st">"firebrick"</span>, <span class="at">size =</span> <span class="dv">2</span>) <span class="sc">+</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="t5_clustering_files/figure-html/ejemplo2.6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="clara" class="level3" data-number="5.3.4">
<h3 data-number="5.3.4" class="anchored" data-anchor-id="clara"><span class="header-section-number">5.3.4</span> Clara</h3>
<p>Una de las limitaciones del método <em>K-medoids-clustering</em> es que su algoritmo requiere mucha memoria RAM, lo que impide que se pueda aplicar cuando el set de datos contiene varios miles de observaciones. CLARA (<em>Clustering Large Applications</em>) es un método que combina la idea de <em>K-medoids</em> con el <em>resampling</em> para que pueda aplicarse a grandes volúmenes de datos.</p>
<p>En lugar de intentar encontrar los <em>medoids</em> empleando todos los datos a la vez, <em>CLARA</em> selecciona una muestra aleatoria de un tamaño determinado y le aplica el algoritmo de <em>PAM</em> (<em>K-medoids</em>) para encontrar los <em>clusters</em> óptimos acorde a esa muestra. Utilizando esos <em>medoids</em> se agrupan las observaciones de todo el set de datos. La calidad de los <em>medoids</em> resultantes se cuantifica con la suma total de las distancias entre cada observación del set de datos y su correspondiente <em>medoid</em> (suma total de distancias <em>intra-clusters</em>). <em>CLARA</em> repite este proceso un número predeterminado de veces con el objetivo de reducir el sesgo del muestreo. Por último, se seleccionan como <em>clusters</em> finales los obtenidos con los <em>medoids</em> que han minimizado la suma total de distancias.</p>
<p>Para más información sobre <em>CLARA</em> y su algoritmo, se recomienda ver la referencia <span class="citation" data-cites="amat">(véase <a href="referencias.html#ref-amat" role="doc-biblioref">Amat 2017</a>)</span>.</p>
</section>
</section>
<section id="jerarquico" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="jerarquico"><span class="header-section-number">5.4</span> Jerarquico</h2>
<section id="introducción-3" class="level3" data-number="5.4.1">
<h3 data-number="5.4.1" class="anchored" data-anchor-id="introducción-3"><span class="header-section-number">5.4.1</span> Introducción</h3>
<p>Los métodos jerárquicos parten de una matriz <span class="math inline">\(D\)</span> de semejanzas o de distancias entre los objetos. Si tenemos <span class="math inline">\(p\)</span> objetos, necesitamos una matriz</p>
<p><span class="math display">\[D=\left( \begin{array}{cccc}
d_{11} &amp; d_{12} &amp; \cdots &amp; d_{1p} \\
d_{21} &amp; d_{22} &amp; \cdots &amp; d_{2p} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
d_{p1} &amp; d_{p2} &amp; \cdots &amp; d_{pp}
\end{array} \right),\]</span></p>
<p>donde cada <span class="math inline">\(d_{ij}\)</span> es la distancia o la semejanza entre el objecto <span class="math inline">\(i\)</span> y el objecto <span class="math inline">\(j\)</span>.</p>
<p>El primer problema es escoger la semejanza o la distancia a utilizar, según el significado que queramos que tenga el clustering. ¡Es una decisión muy importante!</p>
<p>Partimos de <span class="math inline">\(p\)</span> objectos, de los cuales hemos tomado <span class="math inline">\(n\)</span> mediciones, y los organizamos en filas de una matriz</p>
<p><span class="math display">\[X=\left( \begin{array}{cccc}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p} \\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{p1} &amp; x_{p2} &amp; \cdots &amp; x_{pp}
\end{array} \right),\]</span></p>
<p>donde cada entrada es una frecuencia</p>
<p>Sean</p>
<p><span class="math display">\[x_{i\bullet}=\sum_{k=1}^n x_{ik},\quad x_{\bullet k}=\sum_{i=1}^p x_{ik},\quad x_{\bullet\bullet}=\sum_{i=1}^p x_{i\bullet}=\sum_{k=1}^n x_{\bullet k}\]</span> Se recomienda tomar como distancia</p>
<p><span class="math display">\[d_{ij}=\sqrt{\sum_{i=1}^n\frac{x_{\bullet\bullet}}{x_{\bullet k}}\left(\frac{x_{ik}}{x_{i\bullet}}-\frac{x_{jk}}{x_{j\bullet}}\right)^2}\]</span></p>
<p>A 3 bosques se han escogido una area de la misma superficie y se han contado els número de ejemplares de 5 plantes.</p>
<table class="table">
<thead>
<tr class="header">
<th>Bosque</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X</td>
<td>12</td>
<td>3</td>
<td>8</td>
<td>0</td>
<td>24</td>
</tr>
<tr class="even">
<td>Y</td>
<td>3</td>
<td>22</td>
<td>15</td>
<td>8</td>
<td>11</td>
</tr>
<tr class="odd">
<td>Z</td>
<td>0</td>
<td>7</td>
<td>12</td>
<td>20</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>Tabla con frecuencias marginales:</p>
<table class="table">
<thead>
<tr class="header">
<th>Bosque</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th><span class="math inline">\(x_{i\bullet}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X</td>
<td>12</td>
<td>3</td>
<td>8</td>
<td>0</td>
<td>24</td>
<td>47</td>
</tr>
<tr class="even">
<td>Y</td>
<td>3</td>
<td>22</td>
<td>15</td>
<td>8</td>
<td>11</td>
<td>59</td>
</tr>
<tr class="odd">
<td>Z</td>
<td>0</td>
<td>7</td>
<td>12</td>
<td>20</td>
<td>6</td>
<td>45</td>
</tr>
<tr class="even">
<td><span class="math inline">\(x_{\bullet j}\)</span></td>
<td>15</td>
<td>32</td>
<td>35</td>
<td>28</td>
<td>41</td>
<td>151</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\begin{array}{rl}
d^2_{XY}=&amp;\frac{151}{15}\left(\frac{12}{47}-\frac{3}{59}\right)^2+\frac{151}{32}\left(\frac{3}{47}-\frac{22}{59}\right)^2+\frac{151}{35}\left(\frac{8}{47}-\frac{15}{59}\right)^2\\&amp;+\frac{151}{28}\left(\frac{0}{47}-\frac{8}{59}\right)^2+\frac{151}{41}\left(\frac{24}{47}-\frac{11}{59}\right)^2=\ldots
\end{array}\]</span></p>
<p><span class="math display">\[D=\left( \begin{array}{ccc}
0 &amp; 1.178 &amp; 1.525 \\
&amp; 0 &amp; 0.880 \\
&amp; &amp; 0
\end{array} \right)\]</span></p>
<p>Existen dos tipos de métodos de clustering jerárquico:</p>
<ul>
<li>Los algoritmos aglomerativos comienzan con la partición más fina posible (cada objeto constituye un cluster) y los van agrupando.</li>
<li>Los algoritmos de división comienzan con la partición más gruesa posible (todos los objetos constituyen un cluster) y van dividiendo los clusters en clusters más pequeños.</li>
</ul>
<p>Los algoritmos aglomerativos son más populares, porque en general requieren menos tiempo de cálculo</p>
</section>
<section id="ejemplo-2" class="level3" data-number="5.4.2">
<h3 data-number="5.4.2" class="anchored" data-anchor-id="ejemplo-2"><span class="header-section-number">5.4.2</span> Ejemplo</h3>
<p>[AÑADIR TEXTO]</p>
</section>
<section id="jerarquico-aglomerativo" class="level3" data-number="5.4.3">
<h3 data-number="5.4.3" class="anchored" data-anchor-id="jerarquico-aglomerativo"><span class="header-section-number">5.4.3</span> Jerarquico aglomerativo</h3>
<section id="algoritmo" class="level4" data-number="5.4.3.1">
<h4 data-number="5.4.3.1" class="anchored" data-anchor-id="algoritmo"><span class="header-section-number">5.4.3.1</span> Algoritmo</h4>
<ul>
<li>Partimos de <span class="math inline">\(p\)</span> objetos, y de la matriz <span class="math inline">\(p\times p\)</span> de distancias entre ellos</li>
<li>Formamos un cluster con cada objeto</li>
<li>Encontramos dos clusters con la distancia mínima <span class="math inline">\(C_1\)</span> y <span class="math inline">\(C_2\)</span></li>
<li>Unimos <span class="math inline">\(C_1\)</span> y <span class="math inline">\(C_2\)</span> en un cluster nuevo <span class="math inline">\(C_1+C_2\)</span></li>
<li>Eliminamos <span class="math inline">\(C_1\)</span> y <span class="math inline">\(C_2\)</span> de la lista de clusters</li>
<li>Recalculamos la distancia de <span class="math inline">\(C_1+C_2\)</span> a los otros clusters</li>
<li>Repetimos (3)–(6) hasta que solo queda un único cluster</li>
</ul>
<section id="enlaces" class="level5" data-number="5.4.3.1.1">
<h5 data-number="5.4.3.1.1" class="anchored" data-anchor-id="enlaces"><span class="header-section-number">5.4.3.1.1</span> Enlaces</h5>
<p>El cálculo de la distancia entre clusters se puede hacer de diversas maneras, dando lugar a resultados diferentes:</p>
<ul>
<li><p>Para el <span style="color: blue;"><em>enlace simple</em></span>: <span class="math inline">\(d(C,C')=\min\{d(a,b)\mid a\in C,b\in C'\}\)</span>. En este caso <span class="math display">\[d(C,C_1+ C_2)=\min\{d(C,C_1),d(C,C_2)\}.\]</span> Este método tiende a construir clusters grandes: clusters que tendrían que ser diferentes pero que tienen dos individuos cercanos se unen en un único cluster.</p></li>
<li><p>Para el <span style="color: blue;"><em>enlace completo</em></span>: <span class="math inline">\(d(C,C')=\max\{d(a,b)\mid a\in C,b\in C'\}\)</span>. En este caso <span class="math display">\[d(C,C_1+ C_2)=\max\{d(C,C_1),d(C,C_2)\}.\]</span> Este método se va al otro extremo, y tiende a agrupar clusters solo cuando todos los puntos son cercanos.</p></li>
<li><p>Para el <span style="color: blue;"><em>enlace medio</em></span>: <span class="math inline">\(d(C,C')=\frac{\sum_{a\in C, b\in C'} d(a,b)}{|C|\cdot |C'|}\)</span>. En este caso, <span class="math display">\[d(C,C_1+C_2)=\frac{|C_1|}{|C_1|+|C_2|}d(C,C_1)+\frac{|C_2|}{|C_1|+|C_2|}d(C,C_2).\]</span> Este método suele ser una solución intermedia entre el enlace simple y el completo. Es muy utilizado en la reconstrucción de árboles filogenéticos a partir de matrices de distancies (método <strong>UPGMA</strong>, <em>Unweighted Pair Group Method Using Arithmetic averages</em>)</p></li>
<li><p>Para el <span style="color: blue;"><em>método de Ward</em></span>: seguimos un principio muy diferente.&nbsp;&nbsp;Se define la <em>heterogeneidad</em> de un cluster <span class="math inline">\(C\)</span> como <span class="math display">\[I_C = \frac{1}{n_C} \sum_{x_i\in C} d^2(x_i,\mathbf{c}_C),\]</span> donde <span class="math inline">\(\mathbf{c}_C\)</span> representa el punto medio del cluster <span class="math inline">\(C\)</span> respecto de la distancia utilizada. Si <span class="math inline">\(d\)</span> es la distancia euclidiana, <span class="math inline">\(I_C\)</span> es la varianza del cluster <span class="math inline">\(C\)</span>.&nbsp;&nbsp;Cuando dos clusters se unen, <span class="math display">\[I_{C_1+C_2}=I_{C_1}+I_{C_2}+\frac{n_{C_1}\cdot n_{C_2}}{n_{C_1}+ n_{C_2}} d^2 (C_1,C_2).\]</span> El método de Ward une los clusters de manera que el aumento de la suma de las heterogeneidades sea mínima, y el resultado es que los grupos son (globalmente) lo más homogéneos posible.</p></li>
</ul>
<p>En general, conocidas <span class="math inline">\(d(C,C_1\)</span>), <span class="math inline">\(d(C,C_2)\)</span> y <span class="math inline">\((C_1,C_2),\)</span> hay una fórmula genérica para calcular <span class="math inline">\(d(C,C_1+ C_2)\)</span>:</p>
<p><span class="math display">\[\begin{array}{rl}
d(C,C_1+C_2)= &amp;\delta_1 d(C,C_1)+\delta_2 d(C,C_2)+\delta_3 d(C_1,C_2) \\ &amp; + \delta_0 |d(C,C_1)-d(C,C_2)|,
\end{array}\]</span> donde los <span class="math inline">\(\delta_i\)</span> son parámetros a probar. Cada elección da un algoritmo diferente, con resultados posiblemente diferentes.</p>
<p>Si le decimos <span class="math inline">\(n_X\)</span> al número de elementos de un cluster <span class="math inline">\(X\)</span>:</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th>Nom</th>
<th><span class="math inline">\(\delta_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\delta_2\)</span></th>
<th><span class="math inline">\(\delta_3\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\delta_0\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Enlace simple</td>
<td><span class="math inline">\(1/2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1/2\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-1/2\)</span></td>
</tr>
<tr class="even">
<td>Enlace completo</td>
<td><span class="math inline">\(1/2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1/2\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1/2\)</span></td>
</tr>
<tr class="odd">
<td>Enlace medio</td>
<td><span class="math inline">\(\frac{n_{C_1}}{n_{C_1} + n_{C_2}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{n_{C_2}}{n_{C_1}+ n_{C_2}}\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>Centroide</td>
<td><span class="math inline">\(\frac{n_{C_1}}{n_{C_1} + n_{C_2}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{n_{C_2}}{n_{C_1} + n_{C_2}}\)</span></td>
<td><span class="math inline">\(-\frac{n_{C_1} n_{C_2}}{(n_{C_1} + n_{C_2})^2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
</tr>
<tr class="odd">
<td>Mediana</td>
<td><span class="math inline">\(1/2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1/2\)</span></td>
<td><span class="math inline">\(-1/4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>Ward</td>
<td><span class="math inline">\(\frac{n_{C} + n_{C_1}}{n_C + n_{C_1} + n_{C_2}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{n_C + n_{C_2}}{n_C + n_{C_1}+ n_{C_2}}\)</span></td>
<td><span class="math inline">\(-\frac{n_C}{n_C + n_{C_1} + n_{C_2}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="ejemplo-3" class="level4" data-number="5.4.3.2">
<h4 data-number="5.4.3.2" class="anchored" data-anchor-id="ejemplo-3"><span class="header-section-number">5.4.3.2</span> Ejemplo</h4>
<p>A continuación, realizaremos un ejemplo para ver como funciona el algoritmo. <span class="math inline">\(A,B,C,D,E,F,G\)</span> son diferentes tipos de plantas, <span class="math inline">\(x,y\)</span> son genes y nuestros datos son la expresión del gen en condiciones de sequía.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[35,-20,50]]">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="Figuras/tabla0.png" class="img-fluid"></p>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 19.1%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 47.6%;justify-content: center;">
<p><a href="Figuras/jerarquico0.png" class="lightbox" data-gallery="ejemplo-jerarquico"><img src="Figuras/jerarquico0.png" class="img-fluid"></a></p>
</div>
</div>
</div>
<p>En este caso, utilizaremos la distancia euclidiana.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Figuras/tabla1.png" class="img-fluid figure-img"></p>
<figcaption>Matriz de distancias</figcaption>
</figure>
</div>
<p>Usaremos el enlace simple. Ahora, vamos a ilustrar los pasos que sigue el algoritmo uno a uno, y resaltaremos la distancia mínima en rojo a cada paso.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><img src="Figuras/tabla2.png" class="img-fluid"> Substituimos <span class="math inline">\(\{\mathbf{A},\mathbf{B}\}\)</span> por <span class="math inline">\(\mathbf{H}\)</span> y calculamos <img src="Figuras/tabla3.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="Figuras/jerarquico1.png" class="lightbox" data-gallery="ejemplo-jerarquico"><img src="Figuras/jerarquico1.png" class="img-fluid"></a></p>
</div>
</div>
</div>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><img src="Figuras/tabla4.png" class="img-fluid"> Substituimos <span class="math inline">\(\{\mathbf{F},\mathbf{G}\}\)</span> por <span class="math inline">\(\mathbf{I}\)</span> y calculamos <img src="Figuras/tabla5.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="Figuras/jerarquico2.png" class="lightbox" data-gallery="ejemplo-jerarquico"><img src="Figuras/jerarquico2.png" class="img-fluid"></a></p>
</div>
</div>
</div>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><img src="Figuras/tabla6.png" class="img-fluid"> Substituimos <span class="math inline">\(\{\mathbf{H},\mathbf{C}\}\)</span> por <span class="math inline">\(\mathbf{J}\)</span> y calculamos <img src="Figuras/tabla7.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="Figuras/jerarquico3.png" class="lightbox" data-gallery="ejemplo-jerarquico"><img src="Figuras/jerarquico3.png" class="img-fluid"></a></p>
</div>
</div>
</div>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><img src="Figuras/tabla8.png" class="img-fluid"> Substituimos <span class="math inline">\(\{\mathbf{J},\mathbf{D}\}\)</span> por <span class="math inline">\(\mathbf{K}\)</span> y calculamos <img src="Figuras/tabla9.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="Figuras/jerarquico4.png" class="lightbox" data-gallery="ejemplo-jerarquico"><img src="Figuras/jerarquico4.png" class="img-fluid"></a></p>
</div>
</div>
</div>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><img src="Figuras/tabla10.png" class="img-fluid"> Substituimos <span class="math inline">\(\{\mathbf{K},\mathbf{E}\}\)</span> por <span class="math inline">\(\mathbf{L}\)</span> y calculamos <img src="Figuras/tabla11.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="Figuras/jerarquico5.png" class="lightbox" data-gallery="ejemplo-jerarquico"><img src="Figuras/jerarquico5.png" class="img-fluid"></a></p>
</div>
</div>
</div>
<p>Finalmente, unimos <span class="math inline">\(\mathbf{L}\)</span> y <span class="math inline">\(\mathbf{I}\)</span> en un solo cluster</p>
<p><a href="Figuras/jerarquico6.png" class="lightbox" data-gallery="ejemplo-jerarquico"><img src="Figuras/jerarquico6.png" class="img-fluid" style="width:80.0%"></a></p>
</section>
<section id="limitaciones" class="level4" data-number="5.4.3.3">
<h4 data-number="5.4.3.3" class="anchored" data-anchor-id="limitaciones"><span class="header-section-number">5.4.3.3</span> Limitaciones</h4>
<p>Utilizar este método tiene sus complicaciones y restricciones:</p>
<ul>
<li>La distancia utilizada es muy importante</li>
<li>No hay teoría que avale cual método para calcular la distancia entre clusters es el mejor en cada caso</li>
<li>Realmente, no define directamente clusters, pero podemos obtenerlos cortando a una altura del dendrograma</li>
<li>Siempre agrupa de dos en dos, y a vegades toma decisiones aleatorias para conseguirlo</li>
</ul>
</section>
<section id="ejemplo-4" class="level4" data-number="5.4.3.4">
<h4 data-number="5.4.3.4" class="anchored" data-anchor-id="ejemplo-4"><span class="header-section-number">5.4.3.4</span> Ejemplo</h4>
<!-- ```{r Ejemplo-Cesc} -->
<!-- dades = matrix(data=c(0.8,1.8,1.1,1.6, 0.8,1.3,1.0,0.9,1.4, 0.6,1.5, 0.1,1.1,0.1), nrow=7, byrow=TRUE) -->
<!-- distancies = dist(x = dades, method="euclidean"); distancies -->
<!-- clustering = hclust(d = distancies, method="single") -->
<!-- clustering$merge #formació de clusters -->
<!-- clustering$height  #distàncies mínimes -->
<!-- especies=c("A","B","C","D","E","F","G") -->
<!-- plot(clustering,labels=especies) -->
<!-- plot(hclust(distancies,method="single"), labels=especies,hang=-1) -->
<!-- plot(hclust(distancies,method="average"), labels=especies,hang=-1) -->
<!-- plot(hclust(distancies,method="complete"), labels=especies,hang=-1) -->
<!-- plot(hclust(distancies,method="ward.D2"), labels=especies,hang=-1) -->
<!-- ``` -->
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="fu">url</span>(<span class="st">"https://www.causeweb.org/tshs/datasets/ultrarunning.RData"</span>))</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>datos <span class="ot">&lt;-</span> ultrarunning <span class="sc">%&gt;%</span> <span class="fu">as_tibble</span>() <span class="sc">%&gt;%</span> <span class="fu">na.omit</span>(); datos <span class="ot">&lt;-</span> datos[,<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>)] <span class="sc">%&gt;%</span> <span class="fu">scale</span>()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Al aplicar un hierarchical clustering se tiene que escoger una medida de distancia (1-similitud) y un tipo de linkage. En este caso, se emplea la función hclust() indicando la distancia euclídea como medida de similitud y se comparan los linkages complete, single, average y ward.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>matriz_distancias <span class="ot">&lt;-</span> <span class="fu">dist</span>(<span class="at">x =</span> datos, <span class="at">method =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>h_cluster_completo <span class="ot">&lt;-</span> <span class="fu">hclust</span>(<span class="at">d =</span> matriz_distancias, <span class="at">method =</span> <span class="st">"complete"</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>h_cluster_single <span class="ot">&lt;-</span> <span class="fu">hclust</span>(<span class="at">d =</span> matriz_distancias, <span class="at">method =</span> <span class="st">"single"</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>h_cluster_average <span class="ot">&lt;-</span> <span class="fu">hclust</span>(<span class="at">d =</span> matriz_distancias, <span class="at">method =</span> <span class="st">"average"</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>h_cluster_ward <span class="ot">&lt;-</span> <span class="fu">hclust</span>(<span class="at">d =</span> matriz_distancias, <span class="at">method =</span> <span class="st">"ward.D2"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los objetos devueltos por hclust() pueden representarse en forma de dendrograma con la función plot() o con la función fviz_dend() del paquete factoextra.</p>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_dend</span>(<span class="at">x =</span> h_cluster_completo, <span class="at">cex =</span> <span class="fl">0.6</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_dend</span>(<span class="at">x =</span> h_cluster_single, <span class="at">cex =</span> <span class="fl">0.6</span>)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_dend</span>(<span class="at">x =</span> h_cluster_average, <span class="at">cex =</span> <span class="fl">0.6</span>)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_dend</span>(<span class="at">x =</span> h_cluster_ward, <span class="at">cex =</span> <span class="fl">0.6</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="t5_clustering_files/figure-html/ejemplo3.3-1.png" class="lightbox" data-gallery="ejemplo-jerarquical"><img src="t5_clustering_files/figure-html/ejemplo3.3-1.png" class="img-fluid" width="672"></a></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="t5_clustering_files/figure-html/ejemplo3.3-2.png" class="lightbox" data-gallery="ejemplo-jerarquical"><img src="t5_clustering_files/figure-html/ejemplo3.3-2.png" class="img-fluid" width="672"></a></p>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="t5_clustering_files/figure-html/ejemplo3.3-3.png" class="lightbox" data-gallery="ejemplo-jerarquical"><img src="t5_clustering_files/figure-html/ejemplo3.3-3.png" class="img-fluid" width="672"></a></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><a href="t5_clustering_files/figure-html/ejemplo3.3-4.png" class="lightbox" data-gallery="ejemplo-jerarquical"><img src="t5_clustering_files/figure-html/ejemplo3.3-4.png" class="img-fluid" width="672"></a></p>
</div>
</div>
</div>
<p>El conocer que existen 4 grupos en la población permite evaluar qué linkage consigue los mejores resultados. En este caso, los tres tipos identifican claramente 4 clusters, si bien esto no significa que en los 3 dendrogramas los clusters estén formados por exactamente las mismas observaciones.</p>
<p>Una vez creado el dendrograma, hay que evaluar hasta qué punto su estructura refleja las distancias originales entre observaciones. Una forma de hacerlo es empleando el coeficiente de correlación entre las distancias cophenetic del dendrograma (altura de los nodos) y la matriz de distancias original. Cuanto más cercano es el valor a 1, mejor refleja el dendrograma la verdadera similitud entre las observaciones. Valores superiores a 0.75 suelen considerarse como buenos. Esta medida puede emplearse como criterio de ayuda para escoger entre los distintos métodos de linkage. En R, la función cophenetic() calcula las distancias cophenetic de un hierarchical clustering.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(<span class="at">x =</span> matriz_distancias, <span class="fu">cophenetic</span>(h_cluster_completo))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5814256</code></pre>
</div>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(<span class="at">x =</span> matriz_distancias, <span class="fu">cophenetic</span>(h_cluster_single))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6640045</code></pre>
</div>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(<span class="at">x =</span> matriz_distancias, <span class="fu">cophenetic</span>(h_cluster_average))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.7069825</code></pre>
</div>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(<span class="at">x =</span> matriz_distancias, <span class="fu">cophenetic</span>(h_cluster_ward))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.4163869</code></pre>
</div>
</div>
<p>En este caso, el método de linkage average consigue representar ligeramente mejor la similitud entre observaciones.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_dend</span>(<span class="at">x =</span> h_cluster_average, <span class="at">k=</span><span class="dv">8</span>, <span class="at">cex =</span> <span class="fl">0.4</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><a href="t5_clustering_files/figure-html/ejemplo3.5-1.png" class="lightbox" data-gallery="ejemplo-jerarquical"><img src="t5_clustering_files/figure-html/ejemplo3.5-1.png" class="img-fluid figure-img" width="672"></a></p>
</figure>
</div>
</div>
</div>
<p>Una forma visual de comprobar los errores en las asignaciones es indicando en el argumento labels el grupo real al que pertenece cada observación. Si la agrupación resultante coincide con los grupos reales, entonces, dentro de cada clusters las labels serán las mismas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>average_clusters<span class="ot">=</span><span class="fu">cutree</span>(h_cluster_average, <span class="at">k =</span> <span class="dv">8</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>perfil <span class="ot">=</span> <span class="fu">percent_rank</span>(ultrarunning<span class="sc">$</span>teique_sf) <span class="sc">+</span> <span class="fu">percent_rank</span>(ultrarunning<span class="sc">$</span>steu_b) <span class="sc">+</span> <span class="fu">percent_rank</span>(ultrarunning<span class="sc">$</span>stem_b)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>perfil <span class="ot">&lt;-</span> <span class="fu">cut</span>(perfil, <span class="dv">3</span>, <span class="at">labels=</span><span class="fu">c</span>(<span class="st">"Bajo"</span>, <span class="st">"Medio"</span>, <span class="st">"Alto"</span>))</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(average_clusters, perfil)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                perfil
average_clusters Bajo Medio Alto
               1    9    14   14
               2   11    36   22
               3    2     6    4
               4    1     1    0
               5    0     1    1
               6    0     1    0
               7    0     0    1
               8    1     0    0</code></pre>
</div>
</div>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-9">El nuestro</span>
<span class="glightbox-desc lightbox-desc-10">El óptimo</span>
</div>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-amat" class="csl-entry" role="listitem">
Amat, Joaquin. 2017. <span>«Clustering y Heatmaps»</span>. 2017. <a href="https://github.com/JoaquinAmatRodrigo/Estadistica-con-R/blob/master/PDF_format/37_Clustering_y_Heatmaps.pdf">https://github.com/JoaquinAmatRodrigo/Estadistica-con-R/blob/master/PDF_format/37_Clustering_y_Heatmaps.pdf</a>.
</div>
</div>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/aprender-uib\.github\.io\/AD");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./t4_trd.html" class="pagination-link" aria-label="Técnicas de reducción de Dimensionalidad">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Técnicas de reducción de Dimensionalidad</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./t6_series_temporales.html" class="pagination-link" aria-label="Series temporales">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Series temporales</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Análisis de Datos UIB</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/AprendeR-UIB/AD/edit/main/t5_clustering.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li><li><a href="https://github.com/AprendeR-UIB/AD/issues/new" class="toc-action"><i class="bi empty"></i>Informar de un problema</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Este libro se ha creado con <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","selector":".lightbox","loop":false,"descPosition":"bottom","openEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>