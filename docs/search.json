[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análisis de datos (Grado de Matemáticas UIB)",
    "section": "",
    "text": "Presentación\nEsto es una edición en línea de los apuntes de Análisis de Datos del grado de Matemática de la UIB. Hemos escrito estas notas entre varios profesores del Grado."
  },
  {
    "objectID": "intro.html#gestión-básica-de-datos",
    "href": "intro.html#gestión-básica-de-datos",
    "title": "1  Introducción al Análisis Multivariante de Datos",
    "section": "1.1 Gestión básica de datos",
    "text": "1.1 Gestión básica de datos\n\n1.1.0.1 Introducción\n\nEn estadística, siempre se empieza obteniendo unos datos sobre un grupo (relativamente pequeño) de individuos de una población. Bueno, en realidad, no se empieza obteniendo los datos, sino planificando cuidadosamente cómo se van a obtener, pero todo forma parte de la “obtención” de los datos.\nSe generaliza la información que se ha obtenido sobre este grupo de personas al total de la población.\nY no se trata de trucos de magia adivinatoria, sino de una ciencia cuya metodología ha sido validada por medio de demostraciones matemáticas o, en el peor de los casos, mediante simulaciones numéricas (el equivalente en matemáticas de los experimentos en las otras ciencias).\n\nAsí pues, la situación de partida a la hora de aplicar técnicas estadísticas es que disponemos de un conjunto de datos que describen algunas características de un grupo de individuos. El análisis estadístico de estos datos puede ser entonces de dos tipos básicos:\n\nAnálisis exploratorio de datos, cuando nuestro objetivo sea simplemente resumir, representar y explicar los datos concretos de los que disponemos. La estadística descriptiva es el conjunto de técnicas que se usan con este fin.\nAnálisis inferencial, si nuestro objetivo es deducir (inferir), a partir de estos datos, información significativa sobre el total de la población de interés. Las técnicas que se usan en este caso forman la estadística inferencial.\n\n\n\n\n\n\n\n\n\n\nAmbos tipos de análisis están relacionados. Por un lado, porque es conveniente (obligatorio, en nuestra opinión) empezar cualquier análisis inferencial dando un vistazo a los datos que se usarán.\nPor otro, porque muchas técnicas descriptivas permiten estimar propiedades de la población de la que se ha extraído la muestra. Por citar un ejemplo, la media aritmética de las alturas de un grupo de individuos nos da un valor más o menos representativo de sus alturas, pero también sirve para estimar la altura media de los individuos de la población total.\nLa estadística inferencial entra en juego cuando se quiere obtener información sobre una población y no se puede acceder a todos sus integrantes. Si por ejemplo queremos conocer la altura media de los estudiantes matriculados en esta asignatura de la UIB en este curso, en principio no necesitamos para nada la estadística inferencial. Sois pocos, os mediríamos a todos y calcularíamos la media. En todo caso, usaríamos técnicas de estadística descriptiva para arropar este valor representando la distribución de vuestras alturas de manera adecuada.\nPero si quisiéramos conocer la altura media de los mallorquines entre 18 y 25 años, sería muy complicado medirlos a todos. Entonces, lo que haríamos sería tomar una muestra representativa de esta población, medirlos y a partir de sus alturas estimar dicha altura media. Naturalmente, lo más seguro es que de esta manera no obtuviéramos el valor exacto de la altura media de los mallorquines de 18 años, nos tendríamos que conformar con obtener una aproximación dentro de un cierto margen de error y determinar la probabilidad de acertar con nuestra estimación y este margen de error. La estadística inferencial es la que nos permite acotar el error que podamos haber cometido y calcular la probabilidad de cometerlo, incluyendo la metodología que tendríamos que haber usado para tomar la muestra en primer lugar.\n\n\n1.1.0.2 R/ RStudio - Posit / RMarkdowm - Quarto\nTodas las técnicas que usaremos en la asignatura pueden ser implementadas y/o desarrolladas en software libre como Python y R. Ambos se consideran lenguajes de programación esenciales para la ciencia de datos. Lo ideal sería dominar ambos para tener una base de programación completa, pero:\n\nR es un lenguaje específico utilizado para el análisis de datos y la estadística.\nR es muy adecuado para un sub-campo del aprendizaje automático conocido como aprendizaje estadístico. Cualquier persona con una formación formal en estadística debería reconocer la sintaxis y la construcción de R.\nAl igual que Python, R cuenta con una sólida comunidad, estructurada alrededor de la “Comprehensive R Archive Network”, o CRAN, pero no ofrece un desarrollo de software de propósito general como Python.\nCada día salen nuevos paquetes que extienden las funcionalidades de R y cubren casi todas las necesidades computacionales y estadísticas de un científico. Para que os hagáis una idea, en el momento de revisar estas notas (septiembre de 2023) el número de paquetes en el repositorio de la CRAN acaba de superar los 19800.\nEl acceso a R se proporciona a través de RStudio, entorno que presenta una ventana de visualización, un explorador de archivos, un visor de datos y un editor. Este entorno suele ser menos intimidante que el shell de R. Además, cuenta con ayuda integrada, resaltado de sintaxis y completado contextual por tabulaciones; todas estas herramientas facilitan el trabajo.\nRStudio tiene un nuevo nombre desde julio de 2022: Posit. Posit es una palabra que significa proponer una idea para su discusión, proviene de la aspiración científica de construir niveles cada vez mayores de conocimiento y comprensión de experimentos que generan\n\n\n\n\n\n\n\n\n\n\n\nPosit tiene como misión la creación de software libre y de código abierto para la ciencia de datos, la investigación científica y la comunicación técnica. Han incluido algunas herramientas para Python a través de Quarto.\nQuarto está pensado como un cuaderno de laboratorio moderno donde predomina R pero que soporta código Python (reticulate), SQL, Julia, entre otros; pensado para experimentos que requieren multilenguaje.\nPosit Cloud permite acceder al potente conjunto de herramientas de ciencia de datos de Posit directamente desde su navegador. Esto favorecerá el trabajo en equipo. Podéis revisar la siguiente Guía para crearos una cuenta.\n\n\n\n1.1.0.3 Control de versiones con Git / GitHub\n\nEn esta asignatura la forma de llegar a un resultado de análisis de datos es tan importante como el propio resultado. Además, uno de los objetivos es exponeros al uso de herramientas de software para la ciencia de datos moderna.\nLa idea de reproducibilidad lleva implícita la colaboración. El código que se produce es parte de la documentación del proceso y es fundamental compartirlo (aunque sólo sea con uno mismo).\nLo anterior se logra mejor con un sistema de control de versiones distribuido como Git. Mantener un registro sobre los proyectos, es lo que permite rastrear y gestionar cambios en el código a lo largo del tiempo. Se puede decir que nos permite guardar el progreso de nuestro código de tal forma que, si en algún momento cometemos algún error irreversible en una versión posterior, siempre podremos recuperar una versión anterior en la que todo funcionaba correctamente y retomar el proyecto desde ese punto.\nGit permite la colaboración, pero carece de características sociales y herramientas específicas para la colaboración en equipo. GitHub proporciona herramientas para la revisión de código, la gestión de problemas y la colaboración en proyectos.\n\n\n\n\n\n\n\n\n\n\n\nGitHub es un servicio en la nube donde se pueden subir repositorios propios y compartir el código con otras personas de tal forma que sea accesible desde Internet.\nUn repositorio funciona como una carpeta virtual. En él se encuentran todos los archivos de un proyecto y el historial de revisiones de cada uno, permitiendo restablecer una versión del código en caso de error en su ejecución.\nPodemos ver proyectos de otras usuarios, valorarlos, proponer mejoras en el código, GitHub es una de las aplicaciones que mejora la gestión de proyectos y el acceso a recursos compartidos.\nEn octubre del 2021 se estrenó GitHub Copilot, una herramienta de inteligencia artificial en la nube desarrollada conjuntamente entre GitHub y OpenAI. Su objetivo es sugerir y autocompletar el código escrito en entornos de desarrollo integrados (IDE).\n\n\nEn esta clase, utilizaremos GitHub como sistema de gestión del aprendizaje para distribuir y recopilar las entregas como repositorios.\n\n\nCrearemos en GitHub un repositorio por estudiante/equipo para cada entrega. Utilizaremos un sencillo flujo de trabajo centralizado que sólo requiere realizar acciones simples como push, pull, add, rm, commit, status y clone.\n\n\n\n1.1.0.4 Git / GitHub con R\nVeamos cómo configurar todo. Gran parte de lo que está aquí proviene del libro Happy Git and GitHub for the useR de Jenny Bryan y del artículo de David Keyes puedes ver sus vídeos en caso de que, la breve explicación que presentamos abajo, no sea suficiente para ti.\n\nInstalar Git: El primer paso es instalar Git, en el Capítulo 6 del libro explican el proceso para los usuarios de Mac, Windows y Linux. Nosotros ya lo tenemos instalado, así que mostramos cómo verificar si tienes Git instalado y su versión usando el terminal en RStudio.\n\nEn el terminal de RStudio:\n\nwhich git # ruta donde está instalado el Git\ngit --version # version\n\n\nConfigurar Git (Editar gitconfig file):El siguiente paso es configurar Git. Esto se trata en el Capítulo 7 del libro, aunque mostramos lo que creemos es un proceso un poco más fácil. Específicamente, sugerimos usar la función edit_git_config() del paquete usethis, que abrirá su archivo gitconfig. Agrega tu nombre y correo electrónico y cierra esto.\n\nEn la consola de RStudio:\n\nlibrary(usethis)\nusethis::edit_git_config()\n# Modificar en el fichero \".gitconfig\" los apartados: \"name\" y \"email\" \n# y guardar el fichero\n\n\nInicializar un repositorio Git: Ahora que has instalado y configurado Git, puedes usarlo localmente. La función use_git() agregará un repositorio Git (a menudo denominado “repositorio”) a un proyecto RStudio existente. Aquí crearemos un nuevo proyecto y luego inicializaremos un repositorio de Git.\n\nEn RStudio: * Crear un proyecto nuevo\n\nSeleccionar “Nuevo Directorio”\nProyecto\n\nActivar: “Create a git repository”\n\n\nEn la consola de RStudio:\n\nlibrary(usethis)\nusethis::use_git()\n# Elegir siempre la opción: 1\n# Y ante la ventana, seleccionar: \"Save\"\n\nY visitar la pestaña: “Git” en RStudio.\n\nVer historial de confirmación: Ahora que tu proyecto de RStudio tiene un repositorio Git asociado, verás una pestaña adicional en la parte superior derecha: la pestaña Git. Desde aquí, puedes ver todo el historial de cambios en tu código a lo largo del tiempo (¡todavía no muchos!).\n\nEn RStudio:\nVisitar la pestaña: “Git” de RStudio Pulsar el icono del reloj para ver el historial de “Commit” realizados para ver el “Initial Commit”.\n\nHacer una confirmación (commit) y ver más historia: Git no realiza un seguimiento automático de los cambios de la manera en que lo hace una herramienta como Google Docs. En su lugar, tienes que decirle a Git: Hice cambios y quiero que mantengas un registro de ellos. Decirle a Git esto se llama hacer una confirmación (commit) y puedes hacerlo desde RStudio.\n\nCada commit tiene un mensaje de confirmación, lo que es útil porque, cuando miras tu historial de código, ves lo que hiciste en cada momento (es decir, en cada commit). RStudio tiene una herramienta integrada para ver su historial de código. Puedes hacer clic en cualquier commit para ver qué cambió, en relación con el commit anterior. Las líneas que se agregaron en verde; y las que se eliminaron en rojo.\nEn RStudio:\n\nCrear un fichero de script R: “test.R” y guardarlo.\nVisita la pestaña “Git” de RStudio y pulsa sobre el botón de “commit” para confirmar la creación del fichero: “test.R”.\nEn el panel del commit añada un texto que lo defina.\nHaz varios cambios en el fichero “test.R” y en cada uno de ellos haz de nuevo un “commit”.\nRevisa luego la historia de los cambios que se han producido en el historial (pulsar el icono del reloj).\nObserva los nuevos cambios resaltados en color verde. Frente a los valores antiguos que aparecerán en color rojo.\n\n\n\n1.1.0.5 Conectar RStudio y GitHub\nEl proceso hasta ahora nos ha permitido usar Git localmente. Pero, ¿qué pasa si queremos conectarnos a GitHub? ¿Cómo lo hacemos?\nLa mejor manera de conectar RStudio y GitHub es usando tu nombre de usuario y un token de acceso personal (PAT). Para generar un token de acceso personal, usa la función create_github_token() de usethis. Esto te llevará a la página correspondiente en el sitio web de GitHub, donde le darás un nombre a tu token y lo copiarás (¡no lo pierdas porque nunca volverá a aparecer!).\nEn la consola de RStudio:\n\nlibrary(usethis)\nusethis::create_github_token()\n\n\nPulsa sobre el enlace que aparece en la salida en la consola.\nSe abrirá una página web de Github en la que tendrás que pulsar el botón “Generate token”.\nCopia el token que aparece en Github (lo utilizarás en el siguiente paso).\nAhora que has creado un token de acceso personal, debes almacenarlo para que RStudio pueda acceder a él y sepa conectarse a tu cuenta de GitHub. La función gitcreds_set() del paquete gitcreds te ayudará aquí. Ingresará tu nombre de usuario de GitHub y el token de acceso personal como contraseña (NO tu contraseña de GitHub). Una vez que hayas hecho todo esto, ¡habrás conectado RStudio a GitHub!.\n\nEn la consola de RStudio:\n\nlibrary(gitcreds)\ngitcreds::gitcreds_set()\n# Ante la pregunta: \"Enter password or token\"\n# introduce el token copiado en el paso anterior\n\n\n\n1.1.0.6 Conectar proyectos de RStudio con repositorios de GitHub\nAhora que hemos conectado RStudio y GitHub, discutamos cómo hacer que los dos funcionen juntos. La idea básica es que configures los proyectos que creas en RStudio con repositorios GitHub asociados. Cada proyecto de RStudio vive en un solo repositorio de GitHub.\n¿Cómo conectamos un proyecto de RStudio a un repositorio de GitHub? Happy Git and GitHub for the useR propone tres estrategias. Demostraremos la forma más sencilla\ncrear un repositorio en GitHub primero. Cree el repositorio y, a continuación, cuando inicie un nuevo proyecto en RStudio, utilice la opción de control de versiones, introduzca la URL de su repositorio y listo.\nGitHub primero\nCrea el repositorio en GitHub y, a continuación, cuando inicies un nuevo proyecto en RStudio, utiliza la opción de control de versiones, introduce la URL de tu repositorio y listo.\nPara bajar un repositorio creado en Github a un proyecto local en RStudio, tendréis que realizar los siguientes pasos:\n\nCrear un nuevo repositorio en nuestra cuenta de Github (o utilizar uno ya existente): pulsar el botón “Create repository”.\nCopiar al portapapeles la primera dirección que aparece (pulsando el botón de la derecha). Coincide con la dirección url que aparece en la barra del navegador.\nEn RStudio seleccionamos crear “New project”, elegimos “Version Control” y luego seleccionamos “Git”.\nIntroducimos en el primer cuadro de texto la url copiada anteriormente. Pulsamos “Create Project”.\nA continuación podrás consultarse la pestaña “Git” y ver la información asociada al repositorio descargado.\n\n\n\n1.1.0.7 Flujo de trabajo general\nAhora que hemos conectado RStudio y GitHub, podemos compartir nuestro trabajo entre los dos.\nPush (Subir a Github)\n“Push” significa enviar cualquier cambio en tu código de RStudio a GitHub. Para hacer esto, primero tenemos que hacer un commit. Después de confirmar, ahora tenemos un botón (la flecha hacia arriba) en RStudio que podemos usar para enviar nuestro código a GitHub.\nEn RStudio:\n\nCreamos un nuevo fichero de script R o un fichero Rmd y lo guardamos.\nPulsamos en la pestaña “Git” sobre el botón de “commit”. Marcamos todos los ficheros sobre los checks de “Staged”, rellenamos la descripción del commit y pulsamos sobre el botón de “commit”.\nDespués de hacer el commit, pulsamos sobre el botón “Push” para subir los cambios a Github.\nA continuación puedes comprobar en la página de Github del repositorio que se han actualizado los últimos ficheros considerados en el último commit.\n\nPull (Descargar desde Github)\nLo opuesto a “empujar”Push” es bajar (“Pull”). Utilizando el botón de flecha hacia abajo, RStudio va al repositorio de GitHub, toma el código más reciente y lo lleva a su editor local.\nHacer “Push” regularmente es extremadamente importante si estás colaborando, aunque si eres el único que trabaja en un proyecto de RStudio y un repositorio GitHub asociado, sabes que tu código local coincide con lo que está en GitHub, por lo que es menos importante.\nEn la página de Github de nuestro repositorio:\n\nEditamos uno de los ficheros de nuestro repositorio pulsando sobre el icono de un lápiz (a la derecha). Realizamos alguna modificación sobre el fichero (o ficheros).\nPulsamos en la parte inferior de la página en el botón de “Commit changes” (rellenando los comentarios que creamos oportunos sobre el commit que se está realizando). Se puede navegar por la página de Github para consultar todos los commits realizados (y mucha más información).\n\nVolvemos a RStudio:\n\nEn la pestaña “Git” pulsamos sobre el botón de la flecha que apunta hacia abajo (verde) para realizar un “Pull” o descarga de los cambios en Github a nuestro proyecto local en RStudio.\nDespués de eso puedes comprobare que los ficheros locales de nuestro proyecto se han actualizado con los cambios que se han producido en el repositorio.\n\n¡Lo lograste!\n¡Ahora está todo configurado para usar Git y GitHub con RStudio!\n\n\n1.1.1 Los datos y sus tipos\nEn vuestro curso de Estadística estudiasteis algunas técnicas básicas de estadística descriptiva. Estas técnicas consisten en una serie de valores y gráficos que nos permiten resumir y explorar un conjunto de datos, con el objetivo final de entenderlos o describirlos lo mejor posible.\nLos datos de los que disponemos suelen ser multidimensionales, en el sentido de que observamos varias características (variables) de una serie de individuos. Almacenamos estos datos en tablas de datos como la que presentamos abajo, donde cada columna corresponde a una variable y cada fila son los datos de un individuo concreto. Así, en esta tabla, cada fila representa un niño y cada columna recoge una de las características que hemos anotado: su nombre, su altura (en cm), su número de hermanos, el color de sus cabellos, el número semanal de refrescos que suele tomar, y su grado de satisfacción con un juego para móvil (entre 0 y 5).\n\n\n\nUna pequeña tabla de datos sobre niños\n\n\n\nNombre\nAltura\nHermanos\nCabello\nRefrescos semanales\nSatisfacción App\n\n\n\n\n1\nMarta\n135\n2\nrubio\n2-3\n4\n\n\n2\nLaura\n132\n1\nnegro\n2-3\n4\n\n\n3\nXavier\n138\n0\nnegro\n0-1\n3\n\n\n4\nJoan\n141\n3\ncastaño\n4-5\n2\n\n\n5\nMaria\n134\n2\nrojo\n0-1\n3\n\n\n6\nMaria\n136\n1\ncastaño\n6 o más\n5\n\n\n\n\n\n\n\n\n\n\nEn este curso vamos a “sobrecargar” el término variable, en el sentido de que tendrá dos significados diferentes que esperamos que podáis distinguir según el contexto:\n\nPor un lado, llamaremos variable a una característica que puede tomar diferentes valores sobre diferentes individuos; cuando tenga este sentido, a veces le añadiremos el adjetivo poblacional. Por ejemplo, la altura de las personas (de todo el mundo, de un país, de una ciudad…) es una variable poblacional.\nPor otro lado, también llamaremos una variable a un vector formado por los valores de una variable poblacional sobre los sujetos de una muestra. Por ejemplo, las alturas de los niños recogidas en la tabla forman una variable en este sentido.\n\n\n\nLos tipos básicos de datos que consideramos en este curso son los siguientes:\n\nDatos cualitativos. Son los que expresan una cualidad del individuo, como por ejemplo el sexo cromosómico (macho, hembra), el género de una persona (hombre, mujer, lesbiana, gay, bisexual, transexual, intersexual, asexual), tipos de cáncer (de mama, de colon, de próstata…)… Si solo pueden tomar dos valores (“Sí” o “No”, “Macho” o “Hembra”…) los llamamos binarios o dicotómicos y si pueden tomar más de dos valores, politómicos o multicotómicos, dependiendo de lo que queramos complicar los adjetivos. A los posibles valores que puede tomar un tipo de datos cualitativo se los suele llamar niveles.\nLos datos cualitativos pueden ser iguales o distintos, y no admiten ningún otro tipo de comparación.\nDatos ordinales. Son datos similares a los cualitativos, en el sentido de que expresan una cualidad del individuo, pero con la diferencia de que se pueden ordenar de manera natural. Por ejemplo, los niveles de gravedad de una enfermedad (sano, leve, grave, muy grave, …) o las calificaciones en un examen (suspenso, aprobado, notable, sobresaliente) son datos ordinales. En cambio, no se pueden ordenar de manera significativa los sexos o los tipos de cáncer de los individuos: por eso son datos cualitativos y no ordinales.\nTambién se suele llamar a los posibles valores que puede tomar un tipo de datos ordinal sus niveles.\nDatos cuantitativos. Son datos que se refieren a medidas que sean números genuinos, con los que tenga sentido operar, tales como edades, longitudes, pesos, tiempos, números de individuos, etc. Distinguimos dos tipos:\n\nDiscretos: Pueden tomar solo valores que avanzan a saltos y que podemos identificar con números naturales: número de hermanos, número de ingresos en un día en un hospital…\nContinuos: Podrían tomar cualquier valor real dentro de un intervalo si se pudieran medir con precisión infinita: altura, temperatura, tiempo…\n\n\n\nEn la tabla anterior:\n  \n* La variable \"Nombre\" es cualitativa.\n* La variable \"Altura\" es cuantitativa continua.\n* La variable \"Hermanos\" es cuantitativa discreta.\n* La variable \"Cabello\" es cualitativa.\n* La variable \"Refrescos semanales\" es ordinal.\n* La variable \"Satisfacción App\" también es ordinal.\n\n\nDos puntos relevantes a tener en cuenta y que justifican algunas clasificaciones que puede que encontréis dudosas en el ejemplo anterior:\n\nNo todo número es un dato cuantitativo. Solo los consideramos cuantitativos cuando son números genuinos, “de verdad”. Por ejemplo, si pedimos a un paciente que califique su dolor con un número natural de 0 a 10, no es un dato cuantitativo, sino ordinal:\n\nNo es una medida precisa del dolor; no son números “de verdad”, sino abreviaturas de “Nada”, “Un poquito”,…, “Matadme”.\nTener dolor 6 no significa “tener el doble de dolor” que tener dolor 3 (si lo significara, ¿cuál sería el valor correspondiente “al doble de dolor” que 7?). En cambio, una persona con 6 hermanos sí que tiene el doble de hermanos que si tuviera 3.\nNo tiene sentido sumarlos u operarlos en general. Por ejemplo, si yo tengo dolor de nivel 6 y tú tienes dolor de nivel 5, entre los dos no tenemos dolor de nivel 11. En cambio, si yo tengo 6 hermanos y tú 5, entre los dos sí que tenemos 11 hermanos.\n\nEste es justamente el caso de la variable “Satisfacción App” de la tabla anterior. Pese a que sus valores son números, el único contenido real que tienen es su orden: a la María que toma muchos refrescos le ha gustado la app bastante más que a la María que apenas toma refrescos.\nLa distinción discreto-continuo es puramente teórica. En realidad, todo dato es discreto porque no podemos medir nada con precisión infinita, pero las herramientas matemáticas “continuas” (derivadas, integrales, etc.) son mucho más potentes que las discretas, por lo que siempre que tenga sentido, es conveniente considerar una variable como continua.\nObservad, por ejemplo, la diferencia entre la altura, pongamos que medida en cm y redondeada a unidades como en la tabla anterior, y el número de hermanos. Ambos se presentan como números naturales, pero los números de hermanos no admiten mayor precisión, mientras que las alturas las podríamos medir, con los aparatos adecuados, en mm, en µm, en nm…. Como además las herramientas para tratar datos continuos son mucho más potentes, vamos a considerar las alturas como datos continuos, mientras que los números de hermanos no hay más remedio que tratarlos como discretos.\nEn concreto, es conveniente considerar en la práctica como datos continuos aquellos que dan lugar a números naturales muy grandes, como por ejemplo los números de glóbulos rojos en un litro de sangre, de bases nucléicas en un genoma, o de personas de un país. La diferencia entre diez millones, diez millones uno, diez millones dos… puede considerarse como continua: de hecho, si tomamos el millón como unidad, la diferencia está en la séptima cifra decimal.\n\n\n\n\nHemos dicho que la variable “Cabello” es cualitativa. En principio, el color de los cabellos no tiene ningún orden “natural”. Pero si en un estudio definimos un orden claro para esta variable (por ejemplo, por la longitud de onda correspondiente) y este orden es relevante en nuestro estudio, habrá que considerarla una variable ordinal.\n\n\n\n\n\nLa variable “Refrescos semanales” es de un tipo de datos ordinales muy concreto que a veces se califican de cuantitativos agrupados: sus niveles se obtienen agrupando en intervalos los posibles valores de una variable cuantitativa (en este caso, la variable discreta que mide el número preciso de refrescos semanales).\n\n\n\nEl análisis, tanto descriptivo como inferencial, de un conjunto de datos es diferente según su tipo.\n\nAsí, para datos cualitativos sólo tiene interés estudiar y representar las frecuencias con que aparecen sus diferentes valores, mientras que el análisis de datos cuantitativos suele involucrar el cálculo de medidas estadísticas, como la media o la desviación típica, que expresen numéricamente sus propiedades.\nOs dejamos el material Aprender R1 para que repaséis los capítulos 10 al 14 correspondientes a la parte de Estadística descriptiva.\n\n\n1.1.2 Práctica 1:\n\nFormad grupos de 3 integrantes.\nTrabajaréis con los datos pingüinos, leed la documentación y seguid las siguientes instrucciones:\n\nCread un repositorio en Github para vuestro grupo con un nombre que sea fácilmente identificable para los profesores de la asignatura, por ejemplo,“Entrega_1_AD”.\nCread un proyecto nuevo en RStudio conectado al repositorio que habéis creado en el paso anterior. Agregad un documento de quarto donde trabajaréis.\nInstalad y cargad en RStudio la librería palmerpenguins , así como el conjunto de datos penguins\n\n\n\n#install.packages(\"palmerpenguins\",dep=TRUE)\nlibrary(\"palmerpenguins\")\nprint(penguins, width = 50)\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7\n 2 Adelie  Torgersen           39.5          17.4\n 3 Adelie  Torgersen           40.3          18  \n 4 Adelie  Torgersen           NA            NA  \n 5 Adelie  Torgersen           36.7          19.3\n 6 Adelie  Torgersen           39.3          20.6\n 7 Adelie  Torgersen           38.9          17.8\n 8 Adelie  Torgersen           39.2          19.6\n 9 Adelie  Torgersen           34.1          18.1\n10 Adelie  Torgersen           42            20.2\n# ℹ 334 more rows\n# ℹ 4 more variables: flipper_length_mm &lt;int&gt;,\n#   body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\n\n\n\n\n\n\n\n\nCon lo que sabéis de R base, realizad un análisis exploratorio de datos y redactad un reporte con los hallazgos más importantes. No olvidéis agregar en el reporte el URL de vuestro repositorio de GitHub.\nEntregad el reporte en la tarea de Aula Digital disponible. Revisad la fecha en que cierra la tarea.\n\n\n\n1.1.3 Gramática limpia y coherente con Tidyverse\n\n1.1.3.1 La librería Tidyverse\n\n\n\n\n\n\n\n\n\n\nTidyverse es una colección de paquetes/librerías de R para ciencia de datos que comparten una filosofía de diseño, gramática y estructuras similar. En la página Tidverse.org podéis encontrar una descripción detallada de cada una de las librerías, un Blog con artículos de interés para la ciencia de datos, ayuda y recursos de aprendizaje.\nTodos estos paquetes están pensados para:\n\nTener una tecnología con la que puedan convivir diferentes tipos de profesionales (como por ejemplo: informáticos, economistas, matemáticos, gestores) compartiendo el mismo flujo de datos.\nFacilitar el análisis y modelización de datos\n\n\n\n\n\n\n\n\n\n\n\n\nHadley Wickham, su creador, es el director de los científicos de datos de RStudio (actual Posit) y profesor adjunto de estadística en la Universidad de Auckland, la Universidad de Stanford y la Universidad de Rice.\nLas librerías de tidyverse han venido a sustituir R base por su eficiencia y facilidad de programación para no informáticos. Casi todas las consultas a páginas técnicas de R son o incluyen código de tidyverse.\nPaquetes del core de tidyverse:\n\nggplot2: Permite crear gráficos de forma declarativa. Le introducimos los datos, le decimos cómo asignar variables a la estética, qué tipo de gráfico utilizar, y ggplot2 nos devolverá un gráfico más “elegante” y fácil de editar que los de R base.\ndplyr: Gramática de manipulación de datos, un conjunto coherente de acciones que resuelven los retos más comunes como juntar datos y transformarlos.\ntidyr: Conjunto de funciones que ayudan a obtener datos ordenados. Los datos ordenados son datos con una forma consistente: en resumen, cada variable va en una columna, y cada fila es una unidad muestral.\nreadr: Proporciona una forma rápida y amigable de leer datos rectangulares (como csv, tsv).\npurrr: Mejora el conjunto de herramientas de programación funcional (PF) de R proporcionando un conjunto completo y coherente de herramientas para trabajar con funciones y vectores. Una vez dominados los conceptos básicos, purrr permite sustituir muchos bucles for por código más fácil de escribir y más expresivo.\ntibble: Un formato más moderno que el data frame, manteniendo lo que en el tiempo ha demostrado ser eficaz, y desechando lo que no.\nstringr: Conjunto cohesivo de funciones diseñadas para hacer el trabajo con cadenas de texto lo más fácil posible.\nforcats: Conjunto de herramientas útiles que resuelven problemas comunes con factores. R utiliza factores para manejar variables categóricas, variables que tienen un conjunto fijo y conocido de posibles valores.\npurrr: programación funcional (pipes)\n\nHay muchos otros paquetes que se integran sin problemas, por ejemplo, lubridate (para manejar datos tomados en el tiempo), stringr (texto), forcats (factores), etc.\nPara instalar y cargar tidyverse\n\n\n#install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()     masks stats::filter()\n✖ dplyr::group_rows() masks kableExtra::group_rows()\n✖ dplyr::lag()        masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nSe puede ver la versión del paquete tidyverse y la de los paquetes base.\nCuidado: algunas funciones de R se sobrescriben por sus equivalentes de tidyverse. En ocasiones es preferible indicar explícitamente el nombre de la función que deseamos utilizar, por ejemplo: dplyr::group_by para distinguir de plyr::group_by (dplyr es una evolución del paquete plyr).\n\n\n1.1.3.2 ¿Qué significa tidy data?\n\n\n\n\n\n\n\n\n\n\nDecimos que unos datos están bien estructurados o son “tidy data” si se cumplen los siguientes principios:\n\nCada variable forma una columna.\nCada observación forma una fila.\nCada tipo de unidad de observación forma una tabla.\n\n\n\n\n\n\n\n\n\n\n\n\nAlgunas formas de violar los principios de los datos ordenados son:\n\nLas cabeceras de las columnas son valores, no nombres de variables.\nSe almacenan múltiples variables en una columna.\nLas variables se almacenan tanto en filas como en columnas.\nSe almacenan múltiples tipos de unidades de observación en la misma tabla.\nUna misma unidad de observación se almacena en varias tablas.\n\n\nVeamos ejemplos de datos “No tidy” creados a partir del conjunto de datos con el que venimos trabajando de los pingüinos.\nEjemplo 1:\n\n\n# A tibble: 3 × 4\n  species   Biscoe Dream Torgersen\n  &lt;fct&gt;      &lt;int&gt; &lt;int&gt;     &lt;int&gt;\n1 Adelie        44    56        52\n2 Chinstrap     NA    68        NA\n3 Gentoo       124    NA        NA\n\n\nEjemplo 2:\n\n\n# A tibble: 5 × 3\n  col            island     year\n  &lt;chr&gt;          &lt;fct&gt;     &lt;int&gt;\n1 Gentoo_NA      Biscoe     2007\n2 Adelie_male    Torgersen  2007\n3 Gentoo_female  Biscoe     2008\n4 Chinstrap_male Dream      2008\n5 Adelie_male    Torgersen  2009\n\n\nEjemplo 3:\n\n\n# A tibble: 3 × 4\n  term              bill_length_mm bill_depth_mm flipper_length_mm\n  &lt;chr&gt;                      &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n1 bill_length_mm            NA            -0.235             0.656\n2 bill_depth_mm             -0.235        NA                -0.584\n3 flipper_length_mm          0.656        -0.584            NA    \n\n\nEjemplo 4:\n\n\n# A tibble: 6 × 6\n  species   island sex    model              mpg   cyl\n  &lt;fct&gt;     &lt;fct&gt;  &lt;fct&gt;  &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;\n1 Chinstrap Dream  female &lt;NA&gt;              NA      NA\n2 Gentoo    Biscoe female &lt;NA&gt;              NA      NA\n3 Gentoo    Biscoe male   &lt;NA&gt;              NA      NA\n4 &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt;   Merc 450SLC       15.2     8\n5 &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt;   Dodge Challenger  15.5     8\n6 &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt;   Pontiac Firebird  19.2     8\n\n\n\nSi tenemos datos provenientes de distintas fuentes, seguramente tendremos que limpiarlos y juntarlos en un único tibble.\n\n\n\n1.1.3.3 El operador de tuberías (pipe) %&gt;%\n\nLos pipes básicos pasan un valor, atributo u objeto (LHS: Left Hand Side) a la siguiente llamada de función (RHS: Right Hand Side) como primer argumento\n\n\nx %&gt;% f # equivalente a: f(x)\nx %&gt;% f(y) # equivalente a: f(x, y)\nx %&gt;% f %&gt;% g %&gt;% h # equivalente a: h(g(f(x)))\n\n\nLos pipes también se usan con marcadores de posición; en este caso, reenvian un valor u objeto (LHS) a la siguiente llamada de función (RHS) como cualquier argumento.\n\n\nx %&gt;% f(.) # equivalente a: x %&gt;% f\nx %&gt;% f(y, .) # equivalente a: f(y, x)\nx %&gt;% f(y, z = .) # equivalente a: f(y, z = x)\nx %&gt;% f(y = nrow(.),\n        z = ncol(.))  # equivalente a: f(x, y = nrow(x), z = ncol(x))\n\n\nUna secuencia de código que comienza con el marcador de posición (.) devuelve una función que puede utilizarse para aplicar posteriormente la tubería a valores concretos.\n\n\nf &lt;- . %&gt;% cos %&gt;% sin # equivalente a: f &lt;- function(.) sin(cos(.))\n\n\nf(20) # equivalente a: la tubería 20 %&gt;% cos %&gt;% sin\n\n\nPara saber más sobre %&gt;%, haced vignette(\"magrittr\") en la consola de R.\nSe puede obtener %&gt;% en Rstudio desktop utilizando el atajo de teclado: Ctrl + Shift + M.\nEjemplo: ¿Cuál es la masa corporal media, en gramos, de los pingüinos estudiados durante el año 2007?\n\n\n# Sin pipes\nmean(subset(penguins, year == 2007)$body_mass_g, na.rm = T)\n\n[1] 4124.541\n\n# Con pipes (tidyverse)\nresultado &lt;- penguins %&gt;% \n  subset(year == 2007) %&gt;% \n  .$body_mass_g %&gt;% \n  mean(na.rm = T)\n\nLa respuesta a la pregunta formulada sería: “La masa corporal media, en gramos, de los pingüinos estudiados durante el año 2007 es 4125 gramos”.\n\nVentajas de usar pipes:\n\nEl estilo secuencial de las tuberías mejora la lectura del código en comparación con las funciones anidadas.\nHace innecesario almacenar los resultados intermedios.\nEs muy fácil añadir o eliminar pasos (empalmes de tuberías) individuales en el “pipeline”.\n\nLas versiones recientes de R también tienen un operador de tuberías nativo (|&gt;).\n\n\nmtcars |&gt; head(2) #  es lo mismo que  head(mtcars, 2)\n\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n\nmtcars |&gt; subset(cyl == 4) |&gt; nrow()  \n\n[1] 11\n\n\n\n\n1.1.3.4 Data frames avanzados tibbels\nEL paquete tibble proporciona un objeto de tipo data frame mejorado: tbl_df. Un tibble se puede crear de cuatro maneras diferentes.\n\nA partir de vectores columna:\n\n\ntibble(\n  x = c(\"a\", \"b\"),\n  y = c(1, 2),\n  z = c(T, F)\n)\n\n# A tibble: 2 × 3\n  x         y z    \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 a         1 TRUE \n2 b         2 FALSE\n\n\n\nEscribiendo en texto por columnas:\n\n\ntribble(\n  ~x, ~y, ~z,\n  \"a\", 1, T,\n  \"b\", 2, F\n)\n\n# A tibble: 2 × 3\n  x         y z    \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 a         1 TRUE \n2 b         2 FALSE\n\n\n\nCreando un tibble a partir de otro objeto de las clases matrix o data.frame:\n\n\ndata.frame(\n  x = c(\"a\", \"b\"),\n  y = c(1, 2),\n  z = c(T, F)\n) %&gt;% \nas_tibble\n\n# A tibble: 2 × 3\n  x         y z    \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 a         1 TRUE \n2 b         2 FALSE\n\n\n\nCreando un tibble a partir de vectores con nombre:\n\n\nc(x = \"a\", y = \"b\", z = 1) %&gt;%\n  enframe(name = \"x\", value = \"y\")\n\n# A tibble: 3 × 2\n  x     y    \n  &lt;chr&gt; &lt;chr&gt;\n1 x     a    \n2 y     b    \n3 z     1    \n\n\n\nDiferencias entre tibble y data.frame\n\nUn tibble nunca cambia el tipo de entrada. Ya no hay que preocuparse de que los caracteres se conviertan automáticamente en cadenas.\nUn tibble puede tener columnas que son listas.\nUn tibble puede tener nombres de variables no estándar. Pueden empezar por un número o contener espacios. Para utilizarlo se refiere a estos en un backtick, por ejemplo, peso en Kg.\nSólo recicla vectores de longitud 1.\nNo tiene como atributo nombres de filas row.names.\nPor defecto, tibble() imprime sólo las diez primeras filas, todas las columnas que caben en la pantalla, y las clases de las columnas\n\n\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n# data.frame(penguins) recordad que esto imprime todo el data frame\n\n\nglimpse nos da la versión transpuesta de print()\n\n\npenguins %&gt;% glimpse\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\nEl subconjunto de un tibble ([]) siempre devuelve otro tibble y nunca un vector (en contraste con los objetos de un data.frame).\n\n\ndata.frame(penguins) %&gt;% .[, \"species\"] %&gt;% class\n\n[1] \"factor\"\n\n\n\npenguins[, \"species\"] %&gt;% class\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\nEl subconjunto de un data.frame busca el nombre de la variable más parecida\n\n\nnames(data.frame(penguins))\n\n[1] \"species\"           \"island\"            \"bill_length_mm\"   \n[4] \"bill_depth_mm\"     \"flipper_length_mm\" \"body_mass_g\"      \n[7] \"sex\"               \"year\"             \n\nhead(data.frame(penguins)$spec)\n\n[1] Adelie Adelie Adelie Adelie Adelie Adelie\nLevels: Adelie Chinstrap Gentoo\n\n\n\ntibble no permite la coincidencia parcial, es decir, siempre se debe proporcionar el nombre completo de la columna.\n\n\nhead(penguins$spec)\n\nWarning: Unknown or uninitialised column: `spec`.\n\n\nNULL\n\n\n\nhead(penguins$species)\n\n[1] Adelie Adelie Adelie Adelie Adelie Adelie\nLevels: Adelie Chinstrap Gentoo\n\n\n\nLas tibbles dan mejores mensajes Warnings y Errors para solucionar problemas.\n\n\n\n1.1.3.5 Lectura de datos de texto rectangulares readr\nEl paquete readr proporciona funciones de lectura y escritura para múltiples formatos de archivo:\n\nread_delim(): archivos delimitados en general\nread_csv(): archivos separados por comas\nread_csv2(): archivos separados por punto y coma. En la mayoría de los países europeos, Microsoft Excel utiliza ; como delimitador común\nread_tsv(): archivos separados por tabulaciones\nread_fwf(): archivos de ancho fijo\nread_table(): archivos separados por espacios en blanco\nread_log(): archivos de registro web\nConvenientemente, las funciones write_*() funcionan de forma análoga.\nSe utiliza el paquete readxl para archivos de Excel,\nEl paquete haven para archivos de Stata, SAS y SPSS,\nEl paquete googlesheets4 para Google Sheets\nEl paquete rvest para archivos HTML. Esta es la librería de referencia en el contexto de la extracción de datos de la web con R\n\nPara ilustrar el paquete readr, hemos creado previamente un archivo csv que contiene los datos de los pingüinos, utilizando write_csv(penguins, archivo = \"datos/penguins.csv\").\n\ndata &lt;- read_csv(file = \"./datos/penguins.csv\")\n\nNew names:\nRows: 344 Columns: 9\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(3): species, island, sex dbl (6): ...1, bill_length_mm, bill_depth_mm,\nflipper_length_mm, body_mass_g...\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -&gt; `...1`\n\n\n\ndata &lt;- read_csv(file = \"./datos/penguins.csv\", col_select = c(species, island))\n\nNew names:\nRows: 344 Columns: 2\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(2): species, island\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -&gt; `...1`\n\n\n\ndata &lt;- read_csv(file = \"./datos/penguins.csv\",\n                 col_names = paste(\"Var\", 1:8, sep = \"_\"))\n\nRows: 345 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (8): Var_2, Var_3, Var_4, Var_5, Var_6, Var_7, Var_8, X9\ndbl (1): Var_1\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\ndata &lt;- read_csv(file = \"./datos/penguins.csv\", skip = 5)\n\nRows: 339 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): Adelie, Torgersen, female\ndbl (6): 5, 36.7, 19.3, 193, 3450, 2007\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nObserva que} la salida de cualquier función read_*() es un objeto tibble.\nreadr imprime las especificaciones de las columnas después de la importación.\nPor defecto, readr intenta inferir el tipo de columna (por ejemplo, int, dbl, chr, fct, date, lgl) a partir de las primeras 1.000 filas y analiza las columnas en consecuencia.\nUna buena práctica es especificar de forma explícita el formato de las columnas.\n\n\nread_csv(\n  archivo = \"./datos/penguins.csv\",\n  col_types = cols(\n    species = col_character(),\n    año = col_datetime(formato = \"%Y\"),\n    isla = col_skip())\n  )\n\n\nAnalizar sólo las primeras 1.000 filas es eficiente, pero puede llevar a conjeturas erróneas:\n\n\nread_csv(file = \"./datos/penguins.csv\", guess_max = 2000)\n\n\nEncuentra más información y funciones de readr en la hoja de trucos.\nA veces puedes tener problemas al leer datos de texto (tipo carácter): los signos especiales como ö, ä o ü pueden ser codificados de forma extraña como símbolos. En esos casos debes controlar la codificación los datos en la función read_csv (por ejemplo, UTF-8)\nSupongamos que deseamos dejar de utilizar los archivos .xlsx y .csv ya que no son capaces de almacenar de forma fiable los metadatos (por ejemplo, los tipos de datos).\nLas funciones write_rds() y read_rds() (son warppers de writeRDS y readRDS del paquete base de R) proporcionan una buena alternativa para serializar tus objetos R (por ejemplo, tibbles, modelos) y almacenarlos como archivos .rds.\nMás info sobre archivos rds\n\n\npenguins %&gt;% \n  write_rds(file = \"./datos/penguins.rds\")\n\n\npenguins &lt;- read_rds(file = \"./datos/penguins.rds\")\n\nNota que:\n\nwrite_rds() solo puede utilizarse para guardar un objeto a la vez,\nun archivo .rds cargado debe ser almacenado en una nueva variable, es decir, darle un nuevo nombre,\nread_rds() ¡conserva los tipos de datos!\n\n\n\n1.1.3.6 Ordenando datos tidyr\n\nPodemos cambiar el formato de una tabla de datos de largo a ancho y viceversa con las funciones: pivot_longer() y pivot_wider().\n\n\n\n\n\n\n\n\n\n\nTomamos la tabla de datos no tidy del Ejemplo 1 de estas notas y tratamos de estructurarla correctamente. La tabla es la hemos llamado ejemplo1 y la presentamos a continuación:\n\n\n# A tibble: 3 × 4\n  species   Biscoe Dream Torgersen\n  &lt;fct&gt;      &lt;int&gt; &lt;int&gt;     &lt;int&gt;\n1 Adelie        44    56        52\n2 Chinstrap     NA    68        NA\n3 Gentoo       124    NA        NA\n\n\nAplicamos la función pivot_longer para hacerla tidy:\n\nnueva &lt;- ejemplo1 %&gt;% \n  pivot_longer(\n    cols = c(Biscoe, Dream, Torgersen),\n    names_to = \"Isla\", values_to = \"Frecuencia\"\n  )\n\nnueva\n\n# A tibble: 9 × 3\n  species   Isla      Frecuencia\n  &lt;fct&gt;     &lt;chr&gt;          &lt;int&gt;\n1 Adelie    Biscoe            44\n2 Adelie    Dream             56\n3 Adelie    Torgersen         52\n4 Chinstrap Biscoe            NA\n5 Chinstrap Dream             68\n6 Chinstrap Torgersen         NA\n7 Gentoo    Biscoe           124\n8 Gentoo    Dream             NA\n9 Gentoo    Torgersen         NA\n\n\n\nLa función pivot_wider() invierte el efecto de pivot_longer(). Lo dejamos como Ejercicio\nPuedes encontrar más información acerca de pivot_*() en Pivoting . tidyr.\nOtra cosa que podemos hacer es “agrupar”anidar” datos de manera que cada grupo se convierte en una sola fila en un data frame.\n\n\nnested_penguins &lt;- penguins %&gt;% \n    nest(nested_data = \n           c(island, bill_length_mm, \n             bill_depth_mm,flipper_length_mm,\n             body_mass_g, sex))\nnested_penguins\n\n# A tibble: 9 × 3\n  species    year nested_data      \n  &lt;fct&gt;     &lt;int&gt; &lt;list&gt;           \n1 Adelie     2007 &lt;tibble [50 × 6]&gt;\n2 Adelie     2008 &lt;tibble [50 × 6]&gt;\n3 Adelie     2009 &lt;tibble [52 × 6]&gt;\n4 Gentoo     2007 &lt;tibble [34 × 6]&gt;\n5 Gentoo     2008 &lt;tibble [46 × 6]&gt;\n6 Gentoo     2009 &lt;tibble [44 × 6]&gt;\n7 Chinstrap  2007 &lt;tibble [26 × 6]&gt;\n8 Chinstrap  2008 &lt;tibble [18 × 6]&gt;\n9 Chinstrap  2009 &lt;tibble [24 × 6]&gt;\n\n\n\nLa función nest() genera datos anidados en un data frame con una fila por species y year.\nLos datos anidados nested_data por columnas contienen tibbles con seis columnas cada uno y un número de observaciones que pueden ser distintos.\nLos datos anidados son útiles si queremos aplicar funciones a cada subgrupo de datos (por ejemplo, comparar estadísticos por especie).\nPara deshacer las estructuras de datos anidados se puede usar la función tidyr::unnest().\n\n\nnested_penguins %&gt;% unnest(cols = c(nested_data)) \n\n# A tibble: 344 × 8\n   species  year island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;fct&gt;   &lt;int&gt; &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n 1 Adelie   2007 Torgersen           39.1          18.7               181\n 2 Adelie   2007 Torgersen           39.5          17.4               186\n 3 Adelie   2007 Torgersen           40.3          18                 195\n 4 Adelie   2007 Torgersen           NA            NA                  NA\n 5 Adelie   2007 Torgersen           36.7          19.3               193\n 6 Adelie   2007 Torgersen           39.3          20.6               190\n 7 Adelie   2007 Torgersen           38.9          17.8               181\n 8 Adelie   2007 Torgersen           39.2          19.6               195\n 9 Adelie   2007 Torgersen           34.1          18.1               193\n10 Adelie   2007 Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 2 more variables: body_mass_g &lt;int&gt;, sex &lt;fct&gt;\n\n\n\nDividir y combinar múltiples columnas en una sola.\n\n\npenguins %&gt;% unite(col = \"specie_sex\",\n                   c(species, sex), sep = \"_\", remove = T)\n\n# A tibble: 344 × 7\n   specie_sex  island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;       &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie_male Torge…           39.1          18.7               181        3750\n 2 Adelie_fem… Torge…           39.5          17.4               186        3800\n 3 Adelie_fem… Torge…           40.3          18                 195        3250\n 4 Adelie_NA   Torge…           NA            NA                  NA          NA\n 5 Adelie_fem… Torge…           36.7          19.3               193        3450\n 6 Adelie_male Torge…           39.3          20.6               190        3650\n 7 Adelie_fem… Torge…           38.9          17.8               181        3625\n 8 Adelie_male Torge…           39.2          19.6               195        4675\n 9 Adelie_NA   Torge…           34.1          18.1               193        3475\n10 Adelie_NA   Torge…           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 1 more variable: year &lt;int&gt;\n\n\n\nSeparar una sola columna, que contiene varios valores, en varias columnas.\n\n\npenguins %&gt;% separate(bill_length_mm, sep = 2, into = c(\"cm\", \"mm\"))\n\n# A tibble: 344 × 9\n   species island  cm    mm    bill_depth_mm flipper_length_mm body_mass_g sex  \n   &lt;fct&gt;   &lt;fct&gt;   &lt;chr&gt; &lt;chr&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt;\n 1 Adelie  Torger… 39    \".1\"           18.7               181        3750 male \n 2 Adelie  Torger… 39    \".5\"           17.4               186        3800 fema…\n 3 Adelie  Torger… 40    \".3\"           18                 195        3250 fema…\n 4 Adelie  Torger… &lt;NA&gt;  &lt;NA&gt;           NA                  NA          NA &lt;NA&gt; \n 5 Adelie  Torger… 36    \".7\"           19.3               193        3450 fema…\n 6 Adelie  Torger… 39    \".3\"           20.6               190        3650 male \n 7 Adelie  Torger… 38    \".9\"           17.8               181        3625 fema…\n 8 Adelie  Torger… 39    \".2\"           19.6               195        4675 male \n 9 Adelie  Torger… 34    \".1\"           18.1               193        3475 &lt;NA&gt; \n10 Adelie  Torger… 42    \"\"             20.2               190        4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 1 more variable: year &lt;int&gt;\n\n\n\nSeparar una sola columna, que contiene varios valores, en varias filas.\n\n\npenguins %&gt;% separate_rows(island, sep = \"s\", convert = T)\n\n# A tibble: 564 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torger           39.1          18.7               181        3750\n 2 Adelie  en               39.1          18.7               181        3750\n 3 Adelie  Torger           39.5          17.4               186        3800\n 4 Adelie  en               39.5          17.4               186        3800\n 5 Adelie  Torger           40.3          18                 195        3250\n 6 Adelie  en               40.3          18                 195        3250\n 7 Adelie  Torger           NA            NA                  NA          NA\n 8 Adelie  en               NA            NA                  NA          NA\n 9 Adelie  Torger           36.7          19.3               193        3450\n10 Adelie  en               36.7          19.3               193        3450\n# ℹ 554 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\nManejo de los valores perdidos:\n\nSupongamos que tenemos una tibble y queremos hacer explícitos los valores perdidos.\n\n\n# A tibble: 4 × 3\n  species    year measurement\n  &lt;chr&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie     2007        41.6\n2 Adelie     2008        46.5\n3 Gentoo     2008        73.4\n4 Chinstrap  2007        NA  \n\n\nPara hacer explícitos los NAs:\n\nincompl_penguins %&gt;% \n  complete(species, year, fill = list(measurement = NA))\n\n# A tibble: 6 × 3\n  species    year measurement\n  &lt;chr&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie     2007        41.6\n2 Adelie     2008        46.5\n3 Chinstrap  2007        NA  \n4 Chinstrap  2008        NA  \n5 Gentoo     2007        NA  \n6 Gentoo     2008        73.4\n\n\nPara hacer implícitos los valores perdidos explícitos.\n\nincompl_penguins %&gt;% \n  drop_na(measurement)\n\n# A tibble: 3 × 3\n  species  year measurement\n  &lt;chr&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie   2007        41.6\n2 Adelie   2008        46.5\n3 Gentoo   2008        73.4\n\n\n\nReemplazar los valores que faltan por la entrada siguiente o anterior.\n\n\nincompl_penguins %&gt;% \n  fill(measurement, .direction = \"down\")\n\n# A tibble: 4 × 3\n  species    year measurement\n  &lt;chr&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie     2007        41.6\n2 Adelie     2008        46.5\n3 Gentoo     2008        73.4\n4 Chinstrap  2007        73.4\n\n\n\nReemplazar los valores que faltan por un valor predefinido.\n\n\nincompl_penguins %&gt;%\n  replace_na(replace = list(measurement = mean(.$measurement, na.rm = T)))\n\n# A tibble: 4 × 3\n  species    year measurement\n  &lt;chr&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie     2007        41.6\n2 Adelie     2008        46.5\n3 Gentoo     2008        73.4\n4 Chinstrap  2007        53.8\n\n\n\nMás información en tidyr cheatsheet.\nLos argumentos de una función precedidos por un punto en el tidyverse pueden tener una de estas dos razones:\n\nla función es todavía prematura, es decir, los desarrolladores aún piensan en la mejor manera de implementar y nombrar la función\nla función se aplica regularmente dentro de otra función para no confundir los argumentos de la función entre la función interna y la externa"
  }
]